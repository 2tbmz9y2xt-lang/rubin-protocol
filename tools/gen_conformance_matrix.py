#!/usr/bin/env python3
from __future__ import annotations

import argparse
import importlib.util
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable


REPO_ROOT = Path(__file__).resolve().parents[1]
FIXTURES_DIR = REPO_ROOT / "conformance" / "fixtures"
RUNNER_PATH = REPO_ROOT / "conformance" / "runner" / "run_cv_bundle.py"
OUT_PATH = REPO_ROOT / "conformance" / "MATRIX.md"


@dataclass(frozen=True)
class GateRow:
    gate: str
    vectors: int
    ops: tuple[str, ...]
    local_ops: tuple[str, ...]
    executable_ops: tuple[str, ...]


def load_local_ops() -> set[str]:
    spec = importlib.util.spec_from_file_location("rubin_run_cv_bundle", str(RUNNER_PATH))
    if spec is None or spec.loader is None:
        raise RuntimeError(f"cannot load runner module: {RUNNER_PATH}")
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)  # type: ignore[attr-defined]
    local_ops = getattr(mod, "LOCAL_OPS", None)
    if not isinstance(local_ops, set) or not all(isinstance(x, str) for x in local_ops):
        raise RuntimeError("runner LOCAL_OPS missing/invalid")
    return set(local_ops)


def iter_fixtures() -> Iterable[Path]:
    if not FIXTURES_DIR.exists():
        raise RuntimeError(f"missing fixtures dir: {FIXTURES_DIR}")
    return sorted(FIXTURES_DIR.glob("CV-*.json"))


def load_gate_rows(local_ops: set[str]) -> list[GateRow]:
    rows: list[GateRow] = []
    for p in iter_fixtures():
        data = json.loads(p.read_text(encoding="utf-8", errors="strict"))
        if not isinstance(data, dict):
            raise RuntimeError(f"fixture root must be object: {p}")
        gate = data.get("gate")
        vectors = data.get("vectors")
        if not isinstance(gate, str) or not isinstance(vectors, list):
            raise RuntimeError(f"fixture missing gate/vectors: {p}")
        ops = sorted({str(v.get("op", "")) for v in vectors})
        if any(o.strip() == "" for o in ops):
            raise RuntimeError(f"fixture has missing op: {p}")

        local = tuple(sorted([o for o in ops if o in local_ops]))
        executable = tuple(sorted([o for o in ops if o not in local_ops]))
        rows.append(
            GateRow(
                gate=gate,
                vectors=len(vectors),
                ops=tuple(ops),
                local_ops=local,
                executable_ops=executable,
            )
        )
    rows.sort(key=lambda r: r.gate)
    return rows


def render(rows: list[GateRow], local_ops: set[str]) -> str:
    total_vectors = sum(r.vectors for r in rows)
    total_gates = len(rows)
    all_ops = sorted({o for r in rows for o in r.ops})
    all_exec_ops = sorted({o for r in rows for o in r.executable_ops})
    all_local_ops = sorted({o for r in rows for o in r.local_ops})

    def fmt_ops(items: Iterable[str]) -> str:
        return ", ".join(items) if items else "-"

    lines: list[str] = []
    lines.append("# Conformance Matrix (generated)")
    lines.append("")
    lines.append("Generated by `tools/gen_conformance_matrix.py`.")
    lines.append("")
    lines.append("## Summary")
    lines.append("")
    lines.append(f"- Gates: **{total_gates}**")
    lines.append(f"- Vectors: **{total_vectors}**")
    lines.append(f"- Unique ops: **{len(all_ops)}**")
    lines.append(f"- Executable ops (Goâ†”Rust parity): **{len(all_exec_ops)}**")
    lines.append(f"- Local-only ops (runner-defined): **{len(all_local_ops)}**")
    lines.append("")
    lines.append("## Gates")
    lines.append("")
    lines.append("| Gate | Vectors | Ops | Executable ops | Local-only ops |")
    lines.append("| --- | ---: | --- | --- | --- |")
    for r in rows:
        lines.append(
            f"| `{r.gate}` | {r.vectors} | {fmt_ops(r.ops)} | {fmt_ops(r.executable_ops)} | {fmt_ops(r.local_ops)} |"
        )
    lines.append("")
    lines.append("## Local-only ops (runner)")
    lines.append("")
    for op in sorted(local_ops):
        lines.append(f"- `{op}`")
    lines.append("")
    return "\n".join(lines)


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--check", action="store_true", help="fail if conformance/MATRIX.md is out of date")
    args = ap.parse_args()

    local_ops = load_local_ops()
    rows = load_gate_rows(local_ops)
    content = render(rows, local_ops)

    if args.check:
        if not OUT_PATH.exists():
            print(f"ERROR: missing {OUT_PATH}")
            return 1
        cur = OUT_PATH.read_text(encoding="utf-8", errors="strict")
        if cur != content:
            print("ERROR: conformance/MATRIX.md is out of date (run tools/gen_conformance_matrix.py)")
            return 1
        print("OK: conformance/MATRIX.md is up to date")
        return 0

    OUT_PATH.write_text(content, encoding="utf-8")
    print(f"WROTE: {OUT_PATH}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
