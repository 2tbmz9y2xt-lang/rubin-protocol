#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any


def _hex_to_bytes(hex_str: str) -> list[int]:
    s = hex_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    if len(s) % 2 != 0:
        raise ValueError(f"hex length must be even: {len(s)}")
    out: list[int] = []
    for i in range(0, len(s), 2):
        out.append(int(s[i : i + 2], 16))
    return out


def _lean_bytearray_literal(bs: list[int]) -> str:
    if not bs:
        return "#[]"
    return "#[" + ", ".join(f"0x{b:02x}" for b in bs) + "]"


def _lean_opt_str(value: str | None) -> str:
    if value is None:
        return "none"
    v = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'some "{v}"'


def _lean_opt_bytes_hex(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    bs = _hex_to_bytes(hex_str)
    return f"some ({_lean_bytearray_literal(bs)})"


@dataclass(frozen=True)
class ParseVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None


def load_cv_parse(path: Path) -> list[ParseVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-PARSE":
        raise ValueError(f"expected gate=CV-PARSE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ParseVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "parse_tx":
            continue
        out.append(
            ParseVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                expect_ok=bool(v.get("expect_ok")),
                expect_err=(v.get("expect_err") if not v.get("expect_ok") else None),
                expect_txid=(v.get("expect_txid") if v.get("expect_ok") else None),
                expect_wtxid=(v.get("expect_wtxid") if v.get("expect_ok") else None),
            )
        )
    if not out:
        raise ValueError("no parse_tx vectors found")
    return out


def render_cv_parse_lean(vectors: list[ParseVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxid := {_lean_opt_bytes_hex(v.expect_txid)}, "
            + f"expectWtxid := {_lean_opt_bytes_hex(v.expect_wtxid)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-PARSE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVParseVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxid : Option Bytes\n"
        "  expectWtxid : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvParseVectors : List CVParseVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class MerkleVector:
    vid: str
    txids: list[str]
    expect_ok: bool
    expect_merkle_root: str | None
    expect_not_merkle_root: str | None


def load_cv_merkle(path: Path) -> list[MerkleVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-MERKLE":
        raise ValueError(f"expected gate=CV-MERKLE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[MerkleVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "merkle_root":
            continue
        out.append(
            MerkleVector(
                vid=str(v.get("id") or ""),
                txids=list(v.get("txids") or []),
                expect_ok=bool(v.get("expect_ok")),
                expect_merkle_root=(v.get("expect_merkle_root") if v.get("expect_ok") else None),
                expect_not_merkle_root=v.get("expect_not_merkle_root"),
            )
        )
    if not out:
        raise ValueError("no merkle_root vectors found")
    return out


def render_cv_merkle_lean(vectors: list[MerkleVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        txid_bytes = ", ".join(f"({_lean_bytearray_literal(_hex_to_bytes(x))})" for x in v.txids)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txids := [{txid_bytes}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectMerkleRoot := {_lean_opt_bytes_hex(v.expect_merkle_root)}, "
            + f"expectNotMerkleRoot := {_lean_opt_bytes_hex(v.expect_not_merkle_root)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-MERKLE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVMerkleVector where\n"
        "  id : String\n"
        "  txids : List Bytes\n"
        "  expectOk : Bool\n"
        "  expectMerkleRoot : Option Bytes\n"
        "  expectNotMerkleRoot : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvMerkleVectors : List CVMerkleVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Lean vector modules from conformance fixtures")
    parser.add_argument(
        "--repo-root",
        default=None,
        help="Repository root (defaults to auto-detect from this script location).",
    )
    args = parser.parse_args()

    repo_root = Path(args.repo_root).resolve() if args.repo_root else Path(__file__).resolve().parents[2]
    in_path = repo_root / "conformance" / "fixtures" / "CV-PARSE.json"
    out_path = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVParseVectors.lean"

    vectors = load_cv_parse(in_path)
    out_path.write_text(render_cv_parse_lean(vectors), encoding="utf-8")
    print(f"WROTE: {out_path}")

    in_merkle = repo_root / "conformance" / "fixtures" / "CV-MERKLE.json"
    out_merkle = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVMerkleVectors.lean"
    mv = load_cv_merkle(in_merkle)
    out_merkle.write_text(render_cv_merkle_lean(mv), encoding="utf-8")
    print(f"WROTE: {out_merkle}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
