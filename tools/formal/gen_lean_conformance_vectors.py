#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any


def _hex_to_bytes(hex_str: str) -> list[int]:
    s = hex_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    if len(s) % 2 != 0:
        raise ValueError(f"hex length must be even: {len(s)}")
    out: list[int] = []
    for i in range(0, len(s), 2):
        out.append(int(s[i : i + 2], 16))
    return out


def _lean_bytearray_literal(bs: list[int]) -> str:
    if not bs:
        return "#[]"
    return "#[" + ", ".join(f"0x{b:02x}" for b in bs) + "]"


def _lean_opt_str(value: str | None) -> str:
    if value is None:
        return "none"
    v = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'some "{v}"'


def _lean_opt_bytes_hex(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    bs = _hex_to_bytes(hex_str)
    return f"some ({_lean_bytearray_literal(bs)})"


@dataclass(frozen=True)
class ParseVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None


def load_cv_parse(path: Path) -> list[ParseVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-PARSE":
        raise ValueError(f"expected gate=CV-PARSE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ParseVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "parse_tx":
            continue
        out.append(
            ParseVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                expect_ok=bool(v.get("expect_ok")),
                expect_err=(v.get("expect_err") if not v.get("expect_ok") else None),
                expect_txid=(v.get("expect_txid") if v.get("expect_ok") else None),
                expect_wtxid=(v.get("expect_wtxid") if v.get("expect_ok") else None),
            )
        )
    if not out:
        raise ValueError("no parse_tx vectors found")
    return out


def render_cv_parse_lean(vectors: list[ParseVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxid := {_lean_opt_bytes_hex(v.expect_txid)}, "
            + f"expectWtxid := {_lean_opt_bytes_hex(v.expect_wtxid)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-PARSE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVParseVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxid : Option Bytes\n"
        "  expectWtxid : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvParseVectors : List CVParseVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class MerkleVector:
    vid: str
    txids: list[str]
    expect_ok: bool
    expect_merkle_root: str | None
    expect_not_merkle_root: str | None


def load_cv_merkle(path: Path) -> list[MerkleVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-MERKLE":
        raise ValueError(f"expected gate=CV-MERKLE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[MerkleVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "merkle_root":
            continue
        out.append(
            MerkleVector(
                vid=str(v.get("id") or ""),
                txids=list(v.get("txids") or []),
                expect_ok=bool(v.get("expect_ok")),
                expect_merkle_root=(v.get("expect_merkle_root") if v.get("expect_ok") else None),
                expect_not_merkle_root=v.get("expect_not_merkle_root"),
            )
        )
    if not out:
        raise ValueError("no merkle_root vectors found")
    return out


def render_cv_merkle_lean(vectors: list[MerkleVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        txid_bytes = ", ".join(f"({_lean_bytearray_literal(_hex_to_bytes(x))})" for x in v.txids)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txids := [{txid_bytes}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectMerkleRoot := {_lean_opt_bytes_hex(v.expect_merkle_root)}, "
            + f"expectNotMerkleRoot := {_lean_opt_bytes_hex(v.expect_not_merkle_root)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-MERKLE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVMerkleVector where\n"
        "  id : String\n"
        "  txids : List Bytes\n"
        "  expectOk : Bool\n"
        "  expectMerkleRoot : Option Bytes\n"
        "  expectNotMerkleRoot : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvMerkleVectors : List CVMerkleVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def _parse_hex_nat_u16(s: str) -> int:
    t = s.strip()
    if t.startswith("0x") or t.startswith("0X"):
        t = t[2:]
    if len(t) != 4:
        raise ValueError(f"expected u16 hex like 0x0000, got: {s!r}")
    return int(t, 16)


@dataclass(frozen=True)
class OutputDescriptorVector:
    vid: str
    op: str
    covenant_type: int
    covenant_data_hex: str
    expected_hex: str | None
    expected_hash: str | None


def load_cv_output_descriptor(path: Path) -> list[OutputDescriptorVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-OUTPUT-DESCRIPTOR":
        raise ValueError(f"expected gate=CV-OUTPUT-DESCRIPTOR, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[OutputDescriptorVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = v.get("op")
        if op not in ("output_descriptor_bytes", "output_descriptor_hash"):
            continue
        inp = v.get("input") or {}
        out.append(
            OutputDescriptorVector(
                vid=str(v.get("id") or ""),
                op=str(op),
                covenant_type=_parse_hex_nat_u16(str(inp.get("covenant_type") or "")),
                covenant_data_hex=str(inp.get("covenant_data_hex") or ""),
                expected_hex=(v.get("expected_hex") if op == "output_descriptor_bytes" else None),
                expected_hash=(v.get("expected_hash") if op == "output_descriptor_hash" else None),
            )
        )
    if not out:
        raise ValueError("no output_descriptor vectors found")
    return out


def render_cv_output_descriptor_lean(vectors: list[OutputDescriptorVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        covenant_data = _lean_bytearray_literal(_hex_to_bytes(v.covenant_data_hex))
        if v.op == "output_descriptor_bytes":
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hex or ""))
            op = ".bytes"
        else:
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hash or ""))
            op = ".hash"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"covenantType := {v.covenant_type}, "
            + f"covenantData := {covenant_data}, "
            + f"expected := {expected}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-OUTPUT-DESCRIPTOR.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "inductive ODOp where\n"
        "  | bytes\n"
        "  | hash\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVOutputDescriptorVector where\n"
        "  id : String\n"
        "  op : ODOp\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  expected : Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvOutputDescriptorVectors : List CVOutputDescriptorVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class SighashVector:
    vid: str
    tx_hex: str
    chain_id: str
    input_index: int
    input_value: int
    expect_digest: str


def load_cv_sighash(path: Path) -> list[SighashVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SIGHASH":
        raise ValueError(f"expected gate=CV-SIGHASH, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SighashVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "sighash_v1":
            continue
        if not v.get("expect_ok"):
            raise ValueError(f"unexpected expect_ok=false in CV-SIGHASH: {v.get('id')}")
        out.append(
            SighashVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                chain_id=str(v.get("chain_id") or ""),
                input_index=int(v.get("input_index", 0)),
                input_value=int(v.get("input_value", 0)),
                expect_digest=str(v.get("expect_digest") or ""),
            )
        )
    if not out:
        raise ValueError("no sighash_v1 vectors found")
    return out


def render_cv_sighash_lean(vectors: list[SighashVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        chain_id = _lean_bytearray_literal(_hex_to_bytes(v.chain_id))
        digest = _lean_bytearray_literal(_hex_to_bytes(v.expect_digest))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"chainId := {chain_id}, "
            + f"inputIndex := {v.input_index}, "
            + f"inputValue := {v.input_value}, "
            + f"expectDigest := {digest}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-SIGHASH.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVSighashVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  chainId : Bytes\n"
        "  inputIndex : Nat\n"
        "  inputValue : Nat\n"
        "  expectDigest : Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvSighashVectors : List CVSighashVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Lean vector modules from conformance fixtures")
    parser.add_argument(
        "--repo-root",
        default=None,
        help="Repository root (defaults to auto-detect from this script location).",
    )
    args = parser.parse_args()

    repo_root = Path(args.repo_root).resolve() if args.repo_root else Path(__file__).resolve().parents[2]
    in_path = repo_root / "conformance" / "fixtures" / "CV-PARSE.json"
    out_path = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVParseVectors.lean"

    vectors = load_cv_parse(in_path)
    out_path.write_text(render_cv_parse_lean(vectors), encoding="utf-8")
    print(f"WROTE: {out_path}")

    in_merkle = repo_root / "conformance" / "fixtures" / "CV-MERKLE.json"
    out_merkle = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVMerkleVectors.lean"
    mv = load_cv_merkle(in_merkle)
    out_merkle.write_text(render_cv_merkle_lean(mv), encoding="utf-8")
    print(f"WROTE: {out_merkle}")

    in_od = repo_root / "conformance" / "fixtures" / "CV-OUTPUT-DESCRIPTOR.json"
    out_od = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVOutputDescriptorVectors.lean"
    odv = load_cv_output_descriptor(in_od)
    out_od.write_text(render_cv_output_descriptor_lean(odv), encoding="utf-8")
    print(f"WROTE: {out_od}")

    in_sighash = repo_root / "conformance" / "fixtures" / "CV-SIGHASH.json"
    out_sighash = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSighashVectors.lean"
    sv = load_cv_sighash(in_sighash)
    out_sighash.write_text(render_cv_sighash_lean(sv), encoding="utf-8")
    print(f"WROTE: {out_sighash}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
