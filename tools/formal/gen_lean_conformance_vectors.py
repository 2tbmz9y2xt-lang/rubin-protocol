#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any


def _hex_to_bytes(hex_str: str) -> list[int]:
    s = hex_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    if len(s) % 2 != 0:
        raise ValueError(f"hex length must be even: {len(s)}")
    out: list[int] = []
    for i in range(0, len(s), 2):
        out.append(int(s[i : i + 2], 16))
    return out


def _lean_bytearray_literal(bs: list[int]) -> str:
    if not bs:
        return "#[]"
    return "#[" + ", ".join(f"0x{b:02x}" for b in bs) + "]"


def _lean_opt_str(value: str | None) -> str:
    if value is None:
        return "none"
    v = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'some "{v}"'


def _lean_opt_bytes_hex(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    bs = _hex_to_bytes(hex_str)
    return f"some ({_lean_bytearray_literal(bs)})"


@dataclass(frozen=True)
class ParseVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None


def load_cv_parse(path: Path) -> list[ParseVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-PARSE":
        raise ValueError(f"expected gate=CV-PARSE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ParseVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "parse_tx":
            continue
        out.append(
            ParseVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                expect_ok=bool(v.get("expect_ok")),
                expect_err=(v.get("expect_err") if not v.get("expect_ok") else None),
                expect_txid=(v.get("expect_txid") if v.get("expect_ok") else None),
                expect_wtxid=(v.get("expect_wtxid") if v.get("expect_ok") else None),
            )
        )
    if not out:
        raise ValueError("no parse_tx vectors found")
    return out


def render_cv_parse_lean(vectors: list[ParseVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxid := {_lean_opt_bytes_hex(v.expect_txid)}, "
            + f"expectWtxid := {_lean_opt_bytes_hex(v.expect_wtxid)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-PARSE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVParseVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxid : Option Bytes\n"
        "  expectWtxid : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvParseVectors : List CVParseVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class MerkleVector:
    vid: str
    txids: list[str]
    expect_ok: bool
    expect_merkle_root: str | None
    expect_not_merkle_root: str | None


def load_cv_merkle(path: Path) -> list[MerkleVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-MERKLE":
        raise ValueError(f"expected gate=CV-MERKLE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[MerkleVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "merkle_root":
            continue
        out.append(
            MerkleVector(
                vid=str(v.get("id") or ""),
                txids=list(v.get("txids") or []),
                expect_ok=bool(v.get("expect_ok")),
                expect_merkle_root=(v.get("expect_merkle_root") if v.get("expect_ok") else None),
                expect_not_merkle_root=v.get("expect_not_merkle_root"),
            )
        )
    if not out:
        raise ValueError("no merkle_root vectors found")
    return out


def render_cv_merkle_lean(vectors: list[MerkleVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        txid_bytes = ", ".join(f"({_lean_bytearray_literal(_hex_to_bytes(x))})" for x in v.txids)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txids := [{txid_bytes}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectMerkleRoot := {_lean_opt_bytes_hex(v.expect_merkle_root)}, "
            + f"expectNotMerkleRoot := {_lean_opt_bytes_hex(v.expect_not_merkle_root)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-MERKLE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVMerkleVector where\n"
        "  id : String\n"
        "  txids : List Bytes\n"
        "  expectOk : Bool\n"
        "  expectMerkleRoot : Option Bytes\n"
        "  expectNotMerkleRoot : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvMerkleVectors : List CVMerkleVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def _parse_hex_nat_u16(s: str) -> int:
    t = s.strip()
    if t.startswith("0x") or t.startswith("0X"):
        t = t[2:]
    if len(t) != 4:
        raise ValueError(f"expected u16 hex like 0x0000, got: {s!r}")
    return int(t, 16)


@dataclass(frozen=True)
class OutputDescriptorVector:
    vid: str
    op: str
    covenant_type: int
    covenant_data_hex: str
    expected_hex: str | None
    expected_hash: str | None


def load_cv_output_descriptor(path: Path) -> list[OutputDescriptorVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-OUTPUT-DESCRIPTOR":
        raise ValueError(f"expected gate=CV-OUTPUT-DESCRIPTOR, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[OutputDescriptorVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = v.get("op")
        if op not in ("output_descriptor_bytes", "output_descriptor_hash"):
            continue
        inp = v.get("input") or {}
        out.append(
            OutputDescriptorVector(
                vid=str(v.get("id") or ""),
                op=str(op),
                covenant_type=_parse_hex_nat_u16(str(inp.get("covenant_type") or "")),
                covenant_data_hex=str(inp.get("covenant_data_hex") or ""),
                expected_hex=(v.get("expected_hex") if op == "output_descriptor_bytes" else None),
                expected_hash=(v.get("expected_hash") if op == "output_descriptor_hash" else None),
            )
        )
    if not out:
        raise ValueError("no output_descriptor vectors found")
    return out


def render_cv_output_descriptor_lean(vectors: list[OutputDescriptorVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        covenant_data = _lean_bytearray_literal(_hex_to_bytes(v.covenant_data_hex))
        if v.op == "output_descriptor_bytes":
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hex or ""))
            op = ".bytes"
        else:
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hash or ""))
            op = ".hash"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"covenantType := {v.covenant_type}, "
            + f"covenantData := {covenant_data}, "
            + f"expected := {expected}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-OUTPUT-DESCRIPTOR.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "inductive ODOp where\n"
        "  | bytes\n"
        "  | hash\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVOutputDescriptorVector where\n"
        "  id : String\n"
        "  op : ODOp\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  expected : Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvOutputDescriptorVectors : List CVOutputDescriptorVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class PowWindowPattern:
    window_size: int
    start: int
    step: int
    last_jump: int


@dataclass(frozen=True)
class PowVector:
    vid: str
    op: str
    expect_ok: bool
    expect_err: str | None
    target_old: str | None
    timestamp_first: int | None
    timestamp_last: int | None
    window_pattern: PowWindowPattern | None
    header_hex: str | None
    target_hex: str | None
    expected_bytes_hex: str | None


def load_cv_pow(path: Path) -> list[PowVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-POW":
        raise ValueError(f"expected gate=CV-POW, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[PowVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        expect_ok = bool(v.get("expect_ok"))
        expect_err = v.get("expect_err") if not expect_ok else None

        wp: PowWindowPattern | None = None
        if isinstance(v.get("window_pattern"), dict):
            p = v["window_pattern"]
            mode = str(p.get("mode") or "")
            if mode != "step_with_last_jump":
                raise ValueError(f"unknown window_pattern.mode={mode!r} in {v.get('id')!r}")
            wp = PowWindowPattern(
                window_size=int(p.get("window_size", 10_080)),
                start=int(p.get("start", 0)),
                step=int(p.get("step", 120)),
                last_jump=int(p.get("last_jump", 0)),
            )

        target_old = v.get("target_old")
        header_hex = v.get("header_hex")
        target_hex = v.get("target_hex")

        expected_bytes_hex: str | None = None
        if op == "retarget_v1" and expect_ok:
            expected_bytes_hex = str(v.get("expect_target_new") or "")
        if op == "block_hash" and expect_ok:
            expected_bytes_hex = str(v.get("expect_block_hash") or "")

        out.append(
            PowVector(
                vid=str(v.get("id") or ""),
                op=op,
                expect_ok=expect_ok,
                expect_err=expect_err,
                target_old=(str(target_old) if target_old is not None else None),
                timestamp_first=(int(v["timestamp_first"]) if "timestamp_first" in v else None),
                timestamp_last=(int(v["timestamp_last"]) if "timestamp_last" in v else None),
                window_pattern=wp,
                header_hex=(str(header_hex) if header_hex is not None else None),
                target_hex=(str(target_hex) if target_hex is not None else None),
                expected_bytes_hex=expected_bytes_hex,
            )
        )
    if not out:
        raise ValueError("no pow vectors found")
    return out


def _lean_opt_window_pattern(p: PowWindowPattern | None) -> str:
    if p is None:
        return "none"
    return (
        "some { "
        + f"windowSize := {p.window_size}, "
        + f"start := {p.start}, "
        + f"step := {p.step}, "
        + f"lastJump := {p.last_jump}"
        + " }"
    )


def render_cv_pow_lean(vectors: list[PowVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        if v.op == "retarget_v1":
            op = ".retarget_v1"
        elif v.op == "block_hash":
            op = ".block_hash"
        elif v.op == "pow_check":
            op = ".pow_check"
        else:
            raise ValueError(f"unknown op: {v.op!r}")

        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"targetOld := {_lean_opt_bytes_hex(v.target_old)}, "
            + f"timestampFirst := {('some ' + str(v.timestamp_first)) if v.timestamp_first is not None else 'none'}, "
            + f"timestampLast := {('some ' + str(v.timestamp_last)) if v.timestamp_last is not None else 'none'}, "
            + f"windowPattern := {_lean_opt_window_pattern(v.window_pattern)}, "
            + f"header := {_lean_opt_bytes_hex(v.header_hex)}, "
            + f"target := {_lean_opt_bytes_hex(v.target_hex)}, "
            + f"expectedBytes := {_lean_opt_bytes_hex(v.expected_bytes_hex)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-POW.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure WindowPattern where\n"
        "  windowSize : Nat\n"
        "  start : Nat\n"
        "  step : Nat\n"
        "  lastJump : Nat\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "inductive CVPowOp where\n"
        "  | retarget_v1\n"
        "  | block_hash\n"
        "  | pow_check\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVPowVector where\n"
        "  id : String\n"
        "  op : CVPowOp\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  targetOld : Option Bytes\n"
        "  timestampFirst : Option Nat\n"
        "  timestampLast : Option Nat\n"
        "  windowPattern : Option WindowPattern\n"
        "  header : Option Bytes\n"
        "  target : Option Bytes\n"
        "  expectedBytes : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvPowVectors : List CVPowVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Lean vector modules from conformance fixtures")
    parser.add_argument(
        "--repo-root",
        default=None,
        help="Repository root (defaults to auto-detect from this script location).",
    )
    args = parser.parse_args()

    repo_root = Path(args.repo_root).resolve() if args.repo_root else Path(__file__).resolve().parents[2]
    in_path = repo_root / "conformance" / "fixtures" / "CV-PARSE.json"
    out_path = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVParseVectors.lean"

    vectors = load_cv_parse(in_path)
    out_path.write_text(render_cv_parse_lean(vectors), encoding="utf-8")
    print(f"WROTE: {out_path}")

    in_merkle = repo_root / "conformance" / "fixtures" / "CV-MERKLE.json"
    out_merkle = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVMerkleVectors.lean"
    mv = load_cv_merkle(in_merkle)
    out_merkle.write_text(render_cv_merkle_lean(mv), encoding="utf-8")
    print(f"WROTE: {out_merkle}")

    in_od = repo_root / "conformance" / "fixtures" / "CV-OUTPUT-DESCRIPTOR.json"
    out_od = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVOutputDescriptorVectors.lean"
    odv = load_cv_output_descriptor(in_od)
    out_od.write_text(render_cv_output_descriptor_lean(odv), encoding="utf-8")
    print(f"WROTE: {out_od}")

    in_pow = repo_root / "conformance" / "fixtures" / "CV-POW.json"
    out_pow = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVPowVectors.lean"
    pv = load_cv_pow(in_pow)
    out_pow.write_text(render_cv_pow_lean(pv), encoding="utf-8")
    print(f"WROTE: {out_pow}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
