#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any


_PERF_OPTIONS = "set_option maxHeartbeats 10000000\nset_option maxRecDepth 50000\n\n"


def _inject_perf_options(txt: str) -> str:
    if "set_option maxHeartbeats" in txt:
        return txt
    needle = "\n\nnamespace RubinFormal.Conformance\n"
    if needle in txt:
        return txt.replace(needle, "\n\n" + _PERF_OPTIONS + "namespace RubinFormal.Conformance\n", 1)
    return txt


def _hex_to_bytes(hex_str: str) -> list[int]:
    s = hex_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    if len(s) % 2 != 0:
        raise ValueError(f"hex length must be even: {len(s)}")
    out: list[int] = []
    for i in range(0, len(s), 2):
        out.append(int(s[i : i + 2], 16))
    return out


def _lean_bytearray_literal(bs: list[int]) -> str:
    # Make the term type-check as `ByteArray`.
    # `#[...]` alone defaults to `Array Nat` without context.
    if not bs:
        return "⟨#[]⟩"
    return "⟨#[" + ", ".join(f"0x{b:02x}" for b in bs) + "]⟩"


def _lean_opt_str(value: str | None) -> str:
    if value is None:
        return "none"
    v = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'some "{v}"'

def _normalize_hex_str(hex_str: str) -> str:
    s = str(hex_str or "").strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    s = s.lower()
    return "0x" + s

def _lean_hex_str(hex_str: str) -> str:
    v = _normalize_hex_str(hex_str).replace("\\", "\\\\").replace('"', '\\"')
    return f"\"{v}\""

def _lean_opt_hex_str(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    return f"some ({_lean_hex_str(hex_str)})"


def _lean_opt_bytes_hex(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    bs = _hex_to_bytes(hex_str)
    return f"some ({_lean_bytearray_literal(bs)})"


def _render_lean_namespace(source_fixture: str, module_body: str) -> str:
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        f"-- Generated from conformance/fixtures/{source_fixture}.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        + module_body
        + "\n"
        "end RubinFormal.Conformance\n"
    )

def _materialize_tx_hex(v: dict[str, Any]) -> str:
    tx_hex = v.get("tx_hex")
    if isinstance(tx_hex, str) and tx_hex.strip() != "":
        return tx_hex.strip()

    parts = v.get("tx_hex_parts")
    if not isinstance(parts, list) or len(parts) == 0:
        raise ValueError("missing tx_hex (or tx_hex_parts)")

    out: list[str] = []
    for p in parts:
        if isinstance(p, str):
            out.append(p.strip())
            continue
        if isinstance(p, dict):
            repeat_byte = p.get("repeat_byte")
            count = p.get("count")
            if not isinstance(repeat_byte, str) or not isinstance(count, int):
                raise ValueError("tx_hex_parts dict must have repeat_byte (string) and count (int)")
            b = repeat_byte.strip().lower()
            if b.startswith("0x"):
                b = b[2:]
            if len(b) != 2:
                raise ValueError("repeat_byte must be exactly 1 byte hex (2 chars)")
            int(b, 16)  # validate
            if count < 0:
                raise ValueError("repeat_byte count must be non-negative")
            out.append(b * count)
            continue
        raise ValueError("tx_hex_parts entries must be strings or dict repeat blocks")

    return "".join(out)


@dataclass(frozen=True)
class ParseVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None


def load_cv_parse(path: Path) -> list[ParseVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-PARSE":
        raise ValueError(f"expected gate=CV-PARSE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ParseVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "parse_tx":
            continue
        tx_hex = _materialize_tx_hex(v)
        out.append(
            ParseVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                expect_ok=bool(v.get("expect_ok")),
                expect_err=(v.get("expect_err") if not v.get("expect_ok") else None),
                expect_txid=(v.get("expect_txid") if v.get("expect_ok") else None),
                expect_wtxid=(v.get("expect_wtxid") if v.get("expect_ok") else None),
            )
        )
    if not out:
        raise ValueError("no parse_tx vectors found")
    return out


def render_cv_parse_lean(vectors: list[ParseVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxidHex := {_lean_opt_hex_str(v.expect_txid)}, "
            + f"expectWtxidHex := {_lean_opt_hex_str(v.expect_wtxid)}"
            + " }"
        )

    body = ",\n".join(rows)
    module_body = (
        "structure CVParseVector where\n"
        "  id : String\n"
        "  txHex : String\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxidHex : Option String\n"
        "  expectWtxidHex : Option String\n"
        "\n"
        "def cvParseVectors : List CVParseVector := [\n"
        + body
        + "\n]\n"
        "\n"
    )
    return _render_lean_namespace("CV-PARSE", module_body)


@dataclass(frozen=True)
class MerkleVector:
    vid: str
    txids: list[str]
    expect_ok: bool
    expect_merkle_root: str | None
    expect_not_merkle_root: str | None


def load_cv_merkle(path: Path) -> list[MerkleVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-MERKLE":
        raise ValueError(f"expected gate=CV-MERKLE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[MerkleVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "merkle_root":
            continue
        out.append(
            MerkleVector(
                vid=str(v.get("id") or ""),
                txids=list(v.get("txids") or []),
                expect_ok=bool(v.get("expect_ok")),
                expect_merkle_root=(v.get("expect_merkle_root") if v.get("expect_ok") else None),
                expect_not_merkle_root=v.get("expect_not_merkle_root"),
            )
        )
    if not out:
        raise ValueError("no merkle_root vectors found")
    return out


def render_cv_merkle_lean(vectors: list[MerkleVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        txid_hex = ", ".join(_lean_hex_str(x) for x in v.txids)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txidsHex := [{txid_hex}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectMerkleRootHex := {_lean_opt_hex_str(v.expect_merkle_root)}, "
            + f"expectNotMerkleRootHex := {_lean_opt_hex_str(v.expect_not_merkle_root)}"
            + " }"
        )

    body = ",\n".join(rows)
    module_body = (
        "structure CVMerkleVector where\n"
        "  id : String\n"
        "  txidsHex : List String\n"
        "  expectOk : Bool\n"
        "  expectMerkleRootHex : Option String\n"
        "  expectNotMerkleRootHex : Option String\n"
        "\n"
        "def cvMerkleVectors : List CVMerkleVector := [\n"
        + body
        + "\n]\n"
        "\n"
    )
    return _render_lean_namespace("CV-MERKLE", module_body)


def _parse_hex_nat_u16(s: str) -> int:
    t = s.strip()
    if t.startswith("0x") or t.startswith("0X"):
        t = t[2:]
    if len(t) != 4:
        raise ValueError(f"expected u16 hex like 0x0000, got: {s!r}")
    return int(t, 16)


@dataclass(frozen=True)
class OutputDescriptorVector:
    vid: str
    op: str
    covenant_type: int
    covenant_data_hex: str
    expected_hex: str | None
    expected_hash: str | None


def load_cv_output_descriptor(path: Path) -> list[OutputDescriptorVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-OUTPUT-DESCRIPTOR":
        raise ValueError(f"expected gate=CV-OUTPUT-DESCRIPTOR, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[OutputDescriptorVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = v.get("op")
        if op not in ("output_descriptor_bytes", "output_descriptor_hash"):
            continue
        inp = v.get("input") or {}
        out.append(
            OutputDescriptorVector(
                vid=str(v.get("id") or ""),
                op=str(op),
                covenant_type=_parse_hex_nat_u16(str(inp.get("covenant_type") or "")),
                covenant_data_hex=str(inp.get("covenant_data_hex") or ""),
                expected_hex=(v.get("expected_hex") if op == "output_descriptor_bytes" else None),
                expected_hash=(v.get("expected_hash") if op == "output_descriptor_hash" else None),
            )
        )
    if not out:
        raise ValueError("no output_descriptor vectors found")
    return out


def render_cv_output_descriptor_lean(vectors: list[OutputDescriptorVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        if v.op == "output_descriptor_bytes":
            expected_hex = v.expected_hex or ""
            op = ".bytes"
        else:
            expected_hex = v.expected_hash or ""
            op = ".hash"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"covenantType := {v.covenant_type}, "
            + f"covenantDataHex := {_lean_hex_str(v.covenant_data_hex)}, "
            + f"expectedHex := {_lean_hex_str(expected_hex)}"
            + " }"
        )

    body = ",\n".join(rows)
    module_body = (
        "inductive ODOp where\n"
        "  | bytes\n"
        "  | hash\n"
        "deriving DecidableEq\n"
        "\n"
        "structure CVOutputDescriptorVector where\n"
        "  id : String\n"
        "  op : ODOp\n"
        "  covenantType : Nat\n"
        "  covenantDataHex : String\n"
        "  expectedHex : String\n"
        "\n"
        "def cvOutputDescriptorVectors : List CVOutputDescriptorVector := [\n"
        + body
        + "\n]\n"
        "\n"
    )
    return _render_lean_namespace("CV-OUTPUT-DESCRIPTOR", module_body)

@dataclass(frozen=True)
class SighashVector:
    vid: str
    tx_hex: str
    chain_id: str
    input_index: int
    input_value: int
    expect_digest: str


def load_cv_sighash(path: Path) -> list[SighashVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SIGHASH":
        raise ValueError(f"expected gate=CV-SIGHASH, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SighashVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "sighash_v1":
            continue
        if not v.get("expect_ok"):
            raise ValueError(f"unexpected expect_ok=false in CV-SIGHASH: {v.get('id')}")
        tx_hex = _materialize_tx_hex(v)
        out.append(
            SighashVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                chain_id=str(v.get("chain_id") or ""),
                input_index=int(v.get("input_index", 0)),
                input_value=int(v.get("input_value", 0)),
                expect_digest=str(v.get("expect_digest") or ""),
            )
        )
    if not out:
        raise ValueError("no sighash_v1 vectors found")
    return out


def render_cv_sighash_lean(vectors: list[SighashVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"chainIdHex := {_lean_hex_str(v.chain_id)}, "
            + f"inputIndex := {v.input_index}, "
            + f"inputValue := {v.input_value}, "
            + f"expectDigestHex := {_lean_hex_str(v.expect_digest)}"
            + " }"
        )

    body = ",\n".join(rows)
    module_body = (
        "structure CVSighashVector where\n"
        "  id : String\n"
        "  txHex : String\n"
        "  chainIdHex : String\n"
        "  inputIndex : Nat\n"
        "  inputValue : Nat\n"
        "  expectDigestHex : String\n"
        "\n"
        "def cvSighashVectors : List CVSighashVector := [\n"
        + body
        + "\n]\n"
        "\n"
    )
    return _render_lean_namespace("CV-SIGHASH", module_body)


@dataclass(frozen=True)
class WeightVector:
    vid: str
    tx_hex: str
    expect_weight: int
    expect_da_bytes: int
    expect_anchor_bytes: int


def load_cv_weight(path: Path) -> list[WeightVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-WEIGHT":
        raise ValueError(f"expected gate=CV-WEIGHT, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[WeightVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "tx_weight_and_stats":
            continue
        if not v.get("expect_ok"):
            raise ValueError(f"unexpected expect_ok=false in CV-WEIGHT: {v.get('id')}")
        out.append(
            WeightVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                expect_weight=int(v.get("expect_weight", 0)),
                expect_da_bytes=int(v.get("expect_da_bytes", 0)),
                expect_anchor_bytes=int(v.get("expect_anchor_bytes", 0)),
            )
        )
    if not out:
        raise ValueError("no tx_weight_and_stats vectors found")
    return out


def render_cv_weight_lean(vectors: list[WeightVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"expectWeight := {v.expect_weight}, "
            + f"expectDaBytes := {v.expect_da_bytes}, "
            + f"expectAnchorBytes := {v.expect_anchor_bytes}"
            + " }"
        )

    body = ",\n".join(rows)
    module_body = (
        "structure CVWeightVector where\n"
        "  id : String\n"
        "  txHex : String\n"
        "  expectWeight : Nat\n"
        "  expectDaBytes : Nat\n"
        "  expectAnchorBytes : Nat\n"
        "\n"
        "def cvWeightVectors : List CVWeightVector := [\n"
        + body
        + "\n]\n"
        "\n"
    )
    return _render_lean_namespace("CV-WEIGHT", module_body)

@dataclass(frozen=True)
class PowWindowPattern:
    window_size: int
    start: int
    step: int
    last_jump: int


@dataclass(frozen=True)
class PowVector:
    vid: str
    op: str
    expect_ok: bool
    expect_err: str | None
    target_old: str | None
    timestamp_first: int | None
    timestamp_last: int | None
    window_pattern: PowWindowPattern | None
    header_hex: str | None
    target_hex: str | None
    expected_bytes_hex: str | None


def load_cv_pow(path: Path) -> list[PowVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-POW":
        raise ValueError(f"expected gate=CV-POW, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[PowVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        expect_ok = bool(v.get("expect_ok"))
        expect_err = v.get("expect_err") if not expect_ok else None

        wp: PowWindowPattern | None = None
        if isinstance(v.get("window_pattern"), dict):
            p = v["window_pattern"]
            mode = str(p.get("mode") or "")
            if mode != "step_with_last_jump":
                raise ValueError(f"unknown window_pattern.mode={mode!r} in {v.get('id')!r}")
            wp = PowWindowPattern(
                window_size=int(p.get("window_size", 10_080)),
                start=int(p.get("start", 0)),
                step=int(p.get("step", 120)),
                last_jump=int(p.get("last_jump", 0)),
            )

        expected_bytes_hex: str | None = None
        if op == "retarget_v1" and expect_ok:
            expected_bytes_hex = str(v.get("expect_target_new") or "")
        if op == "block_hash" and expect_ok:
            expected_bytes_hex = str(v.get("expect_block_hash") or "")

        out.append(
            PowVector(
                vid=str(v.get("id") or ""),
                op=op,
                expect_ok=expect_ok,
                expect_err=expect_err,
                target_old=(str(v.get("target_old")) if v.get("target_old") is not None else None),
                timestamp_first=(int(v["timestamp_first"]) if "timestamp_first" in v else None),
                timestamp_last=(int(v["timestamp_last"]) if "timestamp_last" in v else None),
                window_pattern=wp,
                header_hex=(str(v.get("header_hex")) if v.get("header_hex") is not None else None),
                target_hex=(str(v.get("target_hex")) if v.get("target_hex") is not None else None),
                expected_bytes_hex=expected_bytes_hex,
            )
        )
    if not out:
        raise ValueError("no pow vectors found")
    return out


def _lean_opt_window_pattern(p: PowWindowPattern | None) -> str:
    if p is None:
        return "none"
    return (
        "some { "
        + f"windowSize := {p.window_size}, "
        + f"start := {p.start}, "
        + f"step := {p.step}, "
        + f"lastJump := {p.last_jump}"
        + " }"
    )


def render_cv_pow_lean(vectors: list[PowVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        if v.op == "retarget_v1":
            op = ".retarget_v1"
        elif v.op == "block_hash":
            op = ".block_hash"
        elif v.op == "pow_check":
            op = ".pow_check"
        else:
            raise ValueError(f"unknown op: {v.op!r}")

        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"targetOldHex := {_lean_opt_hex_str(v.target_old)}, "
            + f"timestampFirst := {('some ' + str(v.timestamp_first)) if v.timestamp_first is not None else 'none'}, "
            + f"timestampLast := {('some ' + str(v.timestamp_last)) if v.timestamp_last is not None else 'none'}, "
            + f"windowPattern := {_lean_opt_window_pattern(v.window_pattern)}, "
            + f"headerHex := {_lean_opt_hex_str(v.header_hex)}, "
            + f"targetHex := {_lean_opt_hex_str(v.target_hex)}, "
            + f"expectedBytesHex := {_lean_opt_hex_str(v.expected_bytes_hex)}"
            + " }"
        )

    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-POW.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure WindowPattern where\n"
        "  windowSize : Nat\n"
        "  start : Nat\n"
        "  step : Nat\n"
        "  lastJump : Nat\n"
        "deriving DecidableEq\n"
        "\n"
        "inductive CVPowOp where\n"
        "  | retarget_v1\n"
        "  | block_hash\n"
        "  | pow_check\n"
        "deriving DecidableEq\n"
        "\n"
        "structure CVPowVector where\n"
        "  id : String\n"
        "  op : CVPowOp\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  targetOldHex : Option String\n"
        "  timestampFirst : Option Nat\n"
        "  timestampLast : Option Nat\n"
        "  windowPattern : Option WindowPattern\n"
        "  headerHex : Option String\n"
        "  targetHex : Option String\n"
        "  expectedBytesHex : Option String\n"
        
        "\n"
        "def cvPowVectors : List CVPowVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class UtxoBasicUtxo:
    txid: str
    vout: int
    value: int
    covenant_type: int
    covenant_data_hex: str
    creation_height: int
    created_by_coinbase: bool


@dataclass(frozen=True)
class UtxoBasicVector:
    vid: str
    tx_hex: str
    utxos: list[UtxoBasicUtxo]
    height: int
    block_timestamp: int
    expect_ok: bool
    expect_err: str | None
    expect_fee: int | None
    expect_utxo_count: int | None


def load_cv_utxo_basic(path: Path) -> list[UtxoBasicVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-UTXO-BASIC":
        raise ValueError(f"expected gate=CV-UTXO-BASIC, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[UtxoBasicVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "utxo_apply_basic":
            continue
        tx_hex = _materialize_tx_hex(v)
        utxos: list[UtxoBasicUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                UtxoBasicUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            UtxoBasicVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                utxos=utxos,
                height=int(v.get("height", 0)),
                block_timestamp=int(v.get("block_timestamp", 0)),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_fee=(int(v.get("expect_fee")) if expect_ok and "expect_fee" in v else None),
                expect_utxo_count=(
                    int(v.get("expect_utxo_count")) if expect_ok and "expect_utxo_count" in v else None
                ),
            )
        )
    if not out:
        raise ValueError("no utxo_apply_basic vectors found")
    return out


def render_cv_utxo_basic_lean(vectors: list[UtxoBasicVector]) -> str:
    def render_utxo(u: UtxoBasicUtxo) -> str:
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txidHex := {_lean_hex_str(u.txid)}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantDataHex := {_lean_hex_str(u.covenant_data_hex)}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"utxos := [{utxo_rows}], "
            + f"height := {v.height}, "
            + f"blockTimestamp := {v.block_timestamp}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectFee := {('some ' + str(v.expect_fee)) if v.expect_fee is not None else 'none'}, "
            + f"expectUtxoCount := {('some ' + str(v.expect_utxo_count)) if v.expect_utxo_count is not None else 'none'}"
            + " }"
        )

    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-UTXO-BASIC.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVUtxoEntry where\n"
        "  txidHex : String\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantDataHex : String\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        
        "\n"
        "structure CVUtxoBasicVector where\n"
        "  id : String\n"
        "  txHex : String\n"
        "  utxos : List CVUtxoEntry\n"
        "  height : Nat\n"
        "  blockTimestamp : Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectFee : Option Nat\n"
        "  expectUtxoCount : Option Nat\n"
        
        "\n"
        "def cvUtxoBasicVectors : List CVUtxoBasicVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class BlockBasicVector:
    vid: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    expect_ok: bool
    expect_err: str | None


def load_cv_block_basic(path: Path) -> list[BlockBasicVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-BLOCK-BASIC":
        raise ValueError(f"expected gate=CV-BLOCK-BASIC, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[BlockBasicVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "block_basic_check":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            BlockBasicVector(
                vid=str(v.get("id") or ""),
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no block_basic_check vectors found")
    return out


def render_cv_block_basic_lean(vectors: list[BlockBasicVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"blockHex := {_lean_hex_str(v.block_hex)}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-BLOCK-BASIC.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVBlockBasicVector where\n"
        "  id : String\n"
        "  blockHex : String\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        
        "\n"
        "def cvBlockBasicVectors : List CVBlockBasicVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class SubsidyUtxo:
    txid: str
    vout: int
    value: int
    covenant_type: int
    covenant_data_hex: str
    creation_height: int
    created_by_coinbase: bool


@dataclass(frozen=True)
class SubsidyVector:
    vid: str
    op: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    height: int
    already_generated: int
    sum_fees: int | None
    utxos: list[SubsidyUtxo]
    expect_ok: bool
    expect_err: str | None


def load_cv_subsidy(path: Path) -> list[SubsidyVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SUBSIDY":
        raise ValueError(f"expected gate=CV-SUBSIDY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SubsidyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("connect_block_basic", "block_basic_check_with_fees"):
            continue
        utxos: list[SubsidyUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                SubsidyUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            SubsidyVector(
                vid=str(v.get("id") or ""),
                op=op,
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                height=int(v.get("height", 0)),
                already_generated=int(v.get("already_generated", 0)),
                sum_fees=(int(v.get("sum_fees")) if "sum_fees" in v else None),
                utxos=utxos,
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no subsidy vectors found")
    return out


def render_cv_subsidy_lean(vectors: list[SubsidyVector]) -> str:
    def render_utxo(u: SubsidyUtxo) -> str:
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txidHex := {_lean_hex_str(u.txid)}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantDataHex := {_lean_hex_str(u.covenant_data_hex)}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        sum_fees = f"some {v.sum_fees}" if v.sum_fees is not None else "none"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := .{v.op}, "
            + f"blockHex := {_lean_hex_str(v.block_hex)}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"height := {v.height}, "
            + f"alreadyGenerated := {v.already_generated}, "
            + f"sumFees := {sum_fees}, "
            + f"utxos := [{utxo_rows}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )

    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-SUBSIDY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "set_option maxHeartbeats 10000000\n"
        "set_option maxRecDepth 50000\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVSubsidyUtxo where\n"
        "  txidHex : String\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantDataHex : String\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        
        "\n"
        "inductive CVSubsidyOp where\n"
        "  | connect_block_basic\n"
        "  | block_basic_check_with_fees\n"
        "deriving DecidableEq\n"
        "\n"
        "structure CVSubsidyVector where\n"
        "  id : String\n"
        "  op : CVSubsidyOp\n"
        "  blockHex : String\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  height : Nat\n"
        "  alreadyGenerated : Nat\n"
        "  sumFees : Option Nat\n"
        "  utxos : List CVSubsidyUtxo\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        
        "\n"
        "def cvSubsidyVectors : List CVSubsidyVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class DaIntegrityVector:
    vid: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    expect_ok: bool
    expect_err: str | None


def load_cv_da_integrity(path: Path) -> list[DaIntegrityVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-DA-INTEGRITY":
        raise ValueError(f"expected gate=CV-DA-INTEGRITY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[DaIntegrityVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "block_basic_check":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            DaIntegrityVector(
                vid=str(v.get("id") or ""),
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no DA integrity vectors found")
    return out


def render_cv_da_integrity_lean(vectors: list[DaIntegrityVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"blockHex := {_lean_hex_str(v.block_hex)}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-DA-INTEGRITY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVDaIntegrityVector where\n"
        "  id : String\n"
        "  blockHex : String\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        
        "\n"
        "def cvDaIntegrityVectors : List CVDaIntegrityVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class CovenantGenesisVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None


def load_cv_covenant_genesis(path: Path) -> list[CovenantGenesisVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-COVENANT-GENESIS":
        raise ValueError(f"expected gate=CV-COVENANT-GENESIS, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[CovenantGenesisVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "covenant_genesis_check":
            continue
        tx_hex = _materialize_tx_hex(v)
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            CovenantGenesisVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no covenant_genesis_check vectors found")
    return out


def render_cv_covenant_genesis_lean(vectors: list[CovenantGenesisVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )

    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-COVENANT-GENESIS.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVCovenantGenesisVector where\n"
        "  id : String\n"
        "  txHex : String\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        
        "\n"
        "def cvCovenantGenesisVectors : List CVCovenantGenesisVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class UtxoApplyVector:
    vid: str
    tx_hex: str
    utxos: list[UtxoBasicUtxo]
    height: int
    block_timestamp: int
    block_mtp: int | None
    expect_ok: bool
    expect_err: str | None
    expect_fee: int | None
    expect_utxo_count: int | None


def _load_utxo_apply_vectors(doc: dict[str, Any], gate: str) -> list[UtxoApplyVector]:
    if doc.get("gate") != gate:
        raise ValueError(f"expected gate={gate}, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[UtxoApplyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "utxo_apply_basic":
            continue
        tx_hex = _materialize_tx_hex(v)
        utxos: list[UtxoBasicUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                UtxoBasicUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            UtxoApplyVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                utxos=utxos,
                height=int(v.get("height", 0)),
                block_timestamp=int(v.get("block_timestamp", 0)),
                block_mtp=(int(v.get("block_mtp")) if "block_mtp" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_fee=(int(v.get("expect_fee")) if expect_ok and "expect_fee" in v else None),
                expect_utxo_count=(
                    int(v.get("expect_utxo_count")) if expect_ok and "expect_utxo_count" in v else None
                ),
            )
        )
    if not out:
        raise ValueError("no utxo_apply_basic vectors found")
    return out


def render_utxo_apply_vectors_lean(vectors: list[UtxoApplyVector], gate: str) -> str:
    def render_utxo(u: UtxoBasicUtxo) -> str:
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txidHex := {_lean_hex_str(u.txid)}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantDataHex := {_lean_hex_str(u.covenant_data_hex)}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txHex := {_lean_hex_str(v.tx_hex)}, "
            + f"utxos := [{utxo_rows}], "
            + f"height := {v.height}, "
            + f"blockTimestamp := {v.block_timestamp}, "
            + f"blockMtp := {('some ' + str(v.block_mtp)) if v.block_mtp is not None else 'none'}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectFee := {('some ' + str(v.expect_fee)) if v.expect_fee is not None else 'none'}, "
            + f"expectUtxoCount := {('some ' + str(v.expect_utxo_count)) if v.expect_utxo_count is not None else 'none'}"
            + " }"
        )
    body = ",\n".join(rows)
    tag = gate.replace("-", "_")
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        f"-- Generated from conformance/fixtures/{gate}.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "set_option maxHeartbeats 10000000\n"
        "set_option maxRecDepth 50000\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        f"structure CVUtxoEntry_{tag} where\n"
        "  txidHex : String\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantDataHex : String\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        
        "\n"
        f"structure CVUtxoApplyVector_{tag} where\n"
        "  id : String\n"
        "  txHex : String\n"
        f"  utxos : List CVUtxoEntry_{tag}\n"
        "  height : Nat\n"
        "  blockTimestamp : Nat\n"
        "  blockMtp : Option Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectFee : Option Nat\n"
        "  expectUtxoCount : Option Nat\n"
        
        "\n"
        f"def cvUtxoApplyVectors_{tag} : List CVUtxoApplyVector_{tag} := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class VaultPolicyVector:
    vid: str
    vault_input_count: int
    owner_lock_id: str
    non_vault_lock_ids: list[str]
    has_owner_auth: bool
    sum_in_vault: int
    sum_out: int
    slots: int
    key_count: int
    sig_threshold_ok: bool
    sentinel_suite_id: int
    sentinel_pubkey_len: int
    sentinel_sig_len: int
    sentinel_verify_called: bool
    whitelist: list[str]
    validation_order: list[str] | None
    expect_ok: bool
    expect_err: str | None


def load_cv_vault_policy(path: Path) -> list[VaultPolicyVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-VAULT-POLICY":
        raise ValueError(f"expected gate=CV-VAULT-POLICY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[VaultPolicyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "vault_policy_rules":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            VaultPolicyVector(
                vid=str(v.get("id") or ""),
                vault_input_count=int(v.get("vault_input_count", 0)),
                owner_lock_id=str(v.get("owner_lock_id", "")),
                non_vault_lock_ids=[str(x) for x in v.get("non_vault_lock_ids", [])],
                has_owner_auth=bool(v.get("has_owner_auth", False)),
                sum_in_vault=int(v.get("sum_in_vault", 0)),
                sum_out=int(v.get("sum_out", 0)),
                slots=int(v.get("slots", 0)),
                key_count=int(v.get("key_count", 0)),
                sig_threshold_ok=bool(v.get("sig_threshold_ok", True)),
                sentinel_suite_id=int(v.get("sentinel_suite_id", 0)),
                sentinel_pubkey_len=int(v.get("sentinel_pubkey_len", 0)),
                sentinel_sig_len=int(v.get("sentinel_sig_len", 0)),
                sentinel_verify_called=bool(v.get("sentinel_verify_called", False)),
                whitelist=[str(x) for x in v.get("whitelist", [])],
                validation_order=([str(x) for x in v["validation_order"]] if "validation_order" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no vault_policy_rules vectors found")
    return out


def render_cv_vault_policy_lean(vectors: list[VaultPolicyVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        non_vault = ", ".join(f"\"{x}\"" for x in v.non_vault_lock_ids)
        wl = ", ".join(f"\"{x}\"" for x in v.whitelist)
        order = (
            "none"
            if v.validation_order is None
            else "some [" + ", ".join(f"\"{x}\"" for x in v.validation_order) + "]"
        )
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"vaultInputCount := {v.vault_input_count}, "
            + f'ownerLockId := "{v.owner_lock_id}", '
            + f"nonVaultLockIds := [{non_vault}], "
            + f"hasOwnerAuth := {'true' if v.has_owner_auth else 'false'}, "
            + f"sumInVault := {v.sum_in_vault}, "
            + f"sumOut := {v.sum_out}, "
            + f"slots := {v.slots}, "
            + f"keyCount := {v.key_count}, "
            + f"sigThresholdOk := {'true' if v.sig_threshold_ok else 'false'}, "
            + f"sentinelSuiteId := {v.sentinel_suite_id}, "
            + f"sentinelPubkeyLen := {v.sentinel_pubkey_len}, "
            + f"sentinelSigLen := {v.sentinel_sig_len}, "
            + f"sentinelVerifyCalled := {'true' if v.sentinel_verify_called else 'false'}, "
            + f"whitelist := [{wl}], "
            + f"validationOrder := {order}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-VAULT-POLICY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVVaultPolicyVector where\n"
        "  id : String\n"
        "  vaultInputCount : Nat\n"
        "  ownerLockId : String\n"
        "  nonVaultLockIds : List String\n"
        "  hasOwnerAuth : Bool\n"
        "  sumInVault : Nat\n"
        "  sumOut : Nat\n"
        "  slots : Nat\n"
        "  keyCount : Nat\n"
        "  sigThresholdOk : Bool\n"
        "  sentinelSuiteId : Nat\n"
        "  sentinelPubkeyLen : Nat\n"
        "  sentinelSigLen : Nat\n"
        "  sentinelVerifyCalled : Bool\n"
        "  whitelist : List String\n"
        "  validationOrder : Option (List String)\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        
        "\n"
        "def cvVaultPolicyVectors : List CVVaultPolicyVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class HtlcOrderingVector:
    vid: str
    path: str
    structural_ok: bool
    locktime_ok: bool
    suite_id: int
    block_height: int
    activation_height: int
    key_binding_ok: bool
    preimage_ok: bool
    verify_ok: bool
    expect_ok: bool
    expect_err: str | None
    expect_verify_called: bool


def load_cv_htlc_ordering(path: Path) -> list[HtlcOrderingVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-HTLC-ORDERING":
        raise ValueError(f"expected gate=CV-HTLC-ORDERING, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[HtlcOrderingVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "htlc_ordering_policy":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            HtlcOrderingVector(
                vid=str(v.get("id") or ""),
                path=str(v.get("path", "claim")),
                structural_ok=bool(v.get("structural_ok", True)),
                locktime_ok=bool(v.get("locktime_ok", True)),
                suite_id=int(v.get("suite_id", 1)),
                block_height=int(v.get("block_height", 0)),
                activation_height=int(v.get("slh_activation_height", 1_000_000)),
                key_binding_ok=bool(v.get("key_binding_ok", True)),
                preimage_ok=bool(v.get("preimage_ok", True)),
                verify_ok=bool(v.get("verify_ok", True)),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_verify_called=bool(v.get("expect_verify_called", False)),
            )
        )
    if not out:
        raise ValueError("no htlc_ordering_policy vectors found")
    return out


def render_cv_htlc_ordering_lean(vectors: list[HtlcOrderingVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'path := "{v.path}", '
            + f"structuralOk := {'true' if v.structural_ok else 'false'}, "
            + f"locktimeOk := {'true' if v.locktime_ok else 'false'}, "
            + f"suiteId := {v.suite_id}, "
            + f"blockHeight := {v.block_height}, "
            + f"slhActivationHeight := {v.activation_height}, "
            + f"keyBindingOk := {'true' if v.key_binding_ok else 'false'}, "
            + f"preimageOk := {'true' if v.preimage_ok else 'false'}, "
            + f"verifyOk := {'true' if v.verify_ok else 'false'}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectVerifyCalled := {'true' if v.expect_verify_called else 'false'}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-HTLC-ORDERING.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVHtlcOrderingVector where\n"
        "  id : String\n"
        "  path : String\n"
        "  structuralOk : Bool\n"
        "  locktimeOk : Bool\n"
        "  suiteId : Nat\n"
        "  blockHeight : Nat\n"
        "  slhActivationHeight : Nat\n"
        "  keyBindingOk : Bool\n"
        "  preimageOk : Bool\n"
        "  verifyOk : Bool\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectVerifyCalled : Bool\n"
        "\n"
        "def cvHtlcOrderingVectors : List CVHtlcOrderingVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class DeterminismVector:
    vid: str
    keys: list[str]
    expect_sorted_keys: list[str]
    expect_ok: bool


def load_cv_determinism(path: Path) -> list[DeterminismVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-DETERMINISM":
        raise ValueError(f"expected gate=CV-DETERMINISM, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[DeterminismVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "determinism_order":
            continue
        out.append(
            DeterminismVector(
                vid=str(v.get("id") or ""),
                keys=list(v.get("keys") or []),
                expect_sorted_keys=list(v.get("expect_sorted_keys") or []),
                expect_ok=bool(v.get("expect_ok")),
            )
        )
    if not out:
        raise ValueError("no determinism vectors found")
    return out


def render_cv_determinism_lean(vectors: list[DeterminismVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        keys = ", ".join(f"\"{x}\"" for x in v.keys)
        sorted_keys = ", ".join(f"\"{x}\"" for x in v.expect_sorted_keys)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"keys := [{keys}], "
            + f"expectSortedKeys := [{sorted_keys}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-DETERMINISM.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVDeterminismVector where\n"
        "  id : String\n"
        "  keys : List String\n"
        "  expectSortedKeys : List String\n"
        "  expectOk : Bool\n"
        "\n"
        "def cvDeterminismVectors : List CVDeterminismVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class ForkChain:
    cid: str
    targets: list[str]
    tip_hash: str


@dataclass(frozen=True)
class ForkChoiceVector:
    vid: str
    op: str
    target: str | None
    chains: list[ForkChain]
    expect_ok: bool
    expect_work: str | None
    expect_winner: str | None


def load_cv_fork_choice(path: Path) -> list[ForkChoiceVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-FORK-CHOICE":
        raise ValueError(f"expected gate=CV-FORK-CHOICE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ForkChoiceVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("fork_work", "fork_choice_select"):
            continue
        chains: list[ForkChain] = []
        for c in v.get("chains") or []:
            if not isinstance(c, dict):
                continue
            chains.append(
                ForkChain(
                    cid=str(c.get("id") or ""),
                    targets=list(c.get("targets") or []),
                    tip_hash=str(c.get("tip_hash") or ""),
                )
            )
        out.append(
            ForkChoiceVector(
                vid=str(v.get("id") or ""),
                op=op,
                target=(str(v.get("target")) if "target" in v else None),
                chains=chains,
                expect_ok=bool(v.get("expect_ok")),
                expect_work=(str(v.get("expect_work")) if "expect_work" in v else None),
                expect_winner=(str(v.get("expect_winner")) if "expect_winner" in v else None),
            )
        )
    if not out:
        raise ValueError("no fork choice vectors found")
    return out


def render_cv_fork_choice_lean(vectors: list[ForkChoiceVector]) -> str:
    def render_chain(c: ForkChain) -> str:
        targets = ", ".join(f"\"{t}\"" for t in c.targets)
        return (
            "{ "
            + f'id := "{c.cid}", '
            + f"targets := [{targets}], "
            + f'tipHash := "{c.tip_hash}"'
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        chains = ", ".join(render_chain(c) for c in v.chains)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'op := "{v.op}", '
            + f"target := {_lean_opt_str(v.target)}, "
            + f"chains := [{chains}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectWork := {_lean_opt_str(v.expect_work)}, "
            + f"expectWinner := {_lean_opt_str(v.expect_winner)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-FORK-CHOICE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure ForkChain where\n"
        "  id : String\n"
        "  targets : List String\n"
        "  tipHash : String\n"
        "\n"
        "structure CVForkChoiceVector where\n"
        "  id : String\n"
        "  op : String\n"
        "  target : Option String\n"
        "  chains : List ForkChain\n"
        "  expectOk : Bool\n"
        "  expectWork : Option String\n"
        "  expectWinner : Option String\n"
        "\n"
        "def cvForkChoiceVectors : List CVForkChoiceVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class ValidationOrderScenario:
    da_set_count: int
    sum_da_bytes: int
    max_da_bytes_per_block: int
    max_da_batches_per_block: int


@dataclass(frozen=True)
class ValidationCheck:
    name: str
    fails: bool
    err: str


@dataclass(frozen=True)
class ValidationOrderVector:
    vid: str
    checks: list[ValidationCheck]
    scenario: ValidationOrderScenario | None
    expect_ok: bool
    expect_first_err: str | None
    expect_evaluated: list[str]


def load_cv_validation_order(path: Path) -> list[ValidationOrderVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-VALIDATION-ORDER":
        raise ValueError(f"expected gate=CV-VALIDATION-ORDER, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ValidationOrderVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "validation_order":
            continue
        checks: list[ValidationCheck] = []
        for c in v.get("checks") or []:
            if not isinstance(c, dict):
                continue
            checks.append(
                ValidationCheck(
                    name=str(c.get("name") or ""),
                    fails=bool(c.get("fails")),
                    err=str(c.get("err") or ""),
                )
            )
        scen = v.get("scenario")
        scenario: ValidationOrderScenario | None = None
        if isinstance(scen, dict):
            scenario = ValidationOrderScenario(
                da_set_count=int(scen.get("da_set_count", 0)),
                sum_da_bytes=int(scen.get("sum_da_bytes", 0)),
                max_da_bytes_per_block=int(scen.get("max_da_bytes_per_block", 0)),
                max_da_batches_per_block=int(scen.get("max_da_batches_per_block", 0)),
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            ValidationOrderVector(
                vid=str(v.get("id") or ""),
                checks=checks,
                scenario=scenario,
                expect_ok=expect_ok,
                expect_first_err=(str(v.get("expect_first_err")) if not expect_ok else None),
                expect_evaluated=list(v.get("expect_evaluated") or []),
            )
        )
    if not out:
        raise ValueError("no validation order vectors found")
    return out


def render_cv_validation_order_lean(vectors: list[ValidationOrderVector]) -> str:
    def render_check(c: ValidationCheck) -> str:
        return (
            "{ "
            + f'name := "{c.name}", '
            + f"fails := {'true' if c.fails else 'false'}, "
            + f'err := "{c.err}"'
            + " }"
        )

    def render_scenario(s: ValidationOrderScenario | None) -> str:
        if s is None:
            return "none"
        return (
            "some { "
            + f"daSetCount := {s.da_set_count}, "
            + f"sumDaBytes := {s.sum_da_bytes}, "
            + f"maxDaBytesPerBlock := {s.max_da_bytes_per_block}, "
            + f"maxDaBatchesPerBlock := {s.max_da_batches_per_block}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        checks = ", ".join(render_check(c) for c in v.checks)
        evaluated = ", ".join(f"\"{x}\"" for x in v.expect_evaluated)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"checks := [{checks}], "
            + f"scenario := {render_scenario(v.scenario)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectFirstErr := {_lean_opt_str(v.expect_first_err)}, "
            + f"expectEvaluated := [{evaluated}]"
            + " }"
        )

    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-VALIDATION-ORDER.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure ValidationCheck where\n"
        "  name : String\n"
        "  fails : Bool\n"
        "  err : String\n"
        "\n"
        "structure ValidationOrderScenario where\n"
        "  daSetCount : Nat\n"
        "  sumDaBytes : Nat\n"
        "  maxDaBytesPerBlock : Nat\n"
        "  maxDaBatchesPerBlock : Nat\n"
        "\n"
        "structure CVValidationOrderVector where\n"
        "  id : String\n"
        "  checks : List ValidationCheck\n"
        "  scenario : Option ValidationOrderScenario\n"
        "  expectOk : Bool\n"
        "  expectFirstErr : Option String\n"
        "  expectEvaluated : List String\n"
        "\n"
        "def cvValidationOrderVectors : List CVValidationOrderVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class ReplayVector:
    vid: str
    op: str
    nonces: list[int]
    expect_duplicates: list[int]
    block_hex: str | None
    expected_prev_hash: str | None
    expected_target: str | None
    prev_timestamps: list[int]
    expect_ok: bool
    expect_err: str | None


def load_cv_replay(path: Path) -> list[ReplayVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-REPLAY":
        raise ValueError(f"expected gate=CV-REPLAY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ReplayVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("nonce_replay_intrablock", "block_basic_check"):
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            ReplayVector(
                vid=str(v.get("id") or ""),
                op=op,
                nonces=list(v.get("nonces") or []),
                expect_duplicates=list(v.get("expect_duplicates") or []),
                block_hex=(str(v.get("block_hex")) if "block_hex" in v else None),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                prev_timestamps=list(v.get("prev_timestamps") or []),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no replay vectors found")
    return out


def render_cv_replay_lean(vectors: list[ReplayVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        nonces = ", ".join(str(x) for x in v.nonces)
        dups = ", ".join(str(x) for x in v.expect_duplicates)
        prev_ts = ", ".join(str(x) for x in v.prev_timestamps)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'op := "{v.op}", '
            + f"nonces := [{nonces}], "
            + f"expectDuplicates := [{dups}], "
            + f"blockHex := {_lean_opt_hex_str(v.block_hex)}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"prevTimestamps := [{prev_ts}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-REPLAY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVReplayVector where\n"
        "  id : String\n"
        "  op : String\n"
        "  nonces : List Nat\n"
        "  expectDuplicates : List Nat\n"
        "  blockHex : Option String\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  prevTimestamps : List Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "\n"
        "def cvReplayVectors : List CVReplayVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class TimestampVector:
    vid: str
    op: str
    mtp: int | None
    timestamp: int | None
    max_future_drift: int | None
    block_hex: str | None
    expected_prev_hash: str | None
    expected_target: str | None
    prev_timestamps: list[int]
    expect_ok: bool
    expect_err: str | None


def load_cv_timestamp(path: Path) -> list[TimestampVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-TIMESTAMP":
        raise ValueError(f"expected gate=CV-TIMESTAMP, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[TimestampVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("timestamp_bounds", "block_basic_check"):
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            TimestampVector(
                vid=str(v.get("id") or ""),
                op=op,
                mtp=(int(v.get("mtp")) if "mtp" in v else None),
                timestamp=(int(v.get("timestamp")) if "timestamp" in v else None),
                max_future_drift=(int(v.get("max_future_drift")) if "max_future_drift" in v else None),
                block_hex=(str(v.get("block_hex")) if "block_hex" in v else None),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                prev_timestamps=list(v.get("prev_timestamps") or []),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no timestamp vectors found")
    return out


def render_cv_timestamp_lean(vectors: list[TimestampVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        prev_ts = ", ".join(str(x) for x in v.prev_timestamps)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'op := "{v.op}", '
            + f"mtp := {('some ' + str(v.mtp)) if v.mtp is not None else 'none'}, "
            + f"timestamp := {('some ' + str(v.timestamp)) if v.timestamp is not None else 'none'}, "
            + f"maxFutureDrift := {('some ' + str(v.max_future_drift)) if v.max_future_drift is not None else 'none'}, "
            + f"blockHex := {_lean_opt_hex_str(v.block_hex)}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"prevTimestamps := [{prev_ts}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-TIMESTAMP.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVTimestampVector where\n"
        "  id : String\n"
        "  op : String\n"
        "  mtp : Option Nat\n"
        "  timestamp : Option Nat\n"
        "  maxFutureDrift : Option Nat\n"
        "  blockHex : Option String\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  prevTimestamps : List Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "\n"
        "def cvTimestampVectors : List CVTimestampVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class SigUtxoEntry:
    txid: str
    vout: int
    value: int
    covenant_type: int
    covenant_data_hex: str
    creation_height: int
    created_by_coinbase: bool


@dataclass(frozen=True)
class SigVector:
    vid: str
    op: str
    tx_hex: str | None
    block_hex: str | None
    utxos: list[SigUtxoEntry]
    height: int | None
    block_timestamp: int | None
    expected_prev_hash: str | None
    expected_target: str | None
    prev_timestamps: list[int]
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None
    expect_consumed: int | None


def load_cv_sig(path: Path) -> list[SigVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SIG":
        raise ValueError(f"expected gate=CV-SIG, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SigVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("parse_tx", "block_basic_check", "utxo_apply_basic"):
            continue

        tx_hex: str | None = None
        if "tx_hex" in v or "tx_hex_parts" in v:
            tx_hex = _materialize_tx_hex(v)

        utxos: list[SigUtxoEntry] = []
        for u in v.get("utxos") or []:
            if not isinstance(u, dict):
                continue
            utxos.append(
                SigUtxoEntry(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )

        expect_ok = bool(v.get("expect_ok"))
        out.append(
            SigVector(
                vid=str(v.get("id") or ""),
                op=op,
                tx_hex=tx_hex,
                block_hex=(str(v.get("block_hex")) if "block_hex" in v else None),
                utxos=utxos,
                height=(int(v.get("height")) if "height" in v else None),
                block_timestamp=(int(v.get("block_timestamp")) if "block_timestamp" in v else None),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                prev_timestamps=list(v.get("prev_timestamps") or []),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_txid=(str(v.get("expect_txid")) if "expect_txid" in v else None),
                expect_wtxid=(str(v.get("expect_wtxid")) if "expect_wtxid" in v else None),
                expect_consumed=(int(v.get("expect_consumed")) if "expect_consumed" in v else None),
            )
        )
    if not out:
        raise ValueError("no CV-SIG vectors found")
    return out


def render_cv_sig_lean(vectors: list[SigVector]) -> str:
    def render_utxo(u: SigUtxoEntry) -> str:
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txidHex := {_lean_hex_str(u.txid)}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantDataHex := {_lean_hex_str(u.covenant_data_hex)}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        tx = _lean_opt_hex_str(v.tx_hex)
        block = _lean_opt_hex_str(v.block_hex)
        utxos = ", ".join(render_utxo(u) for u in v.utxos)
        prev_ts = ", ".join(str(x) for x in v.prev_timestamps)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'op := "{v.op}", '
            + f"txHex := {tx}, "
            + f"blockHex := {block}, "
            + f"utxos := [{utxos}], "
            + f"height := {('some ' + str(v.height)) if v.height is not None else 'none'}, "
            + f"blockTimestamp := {('some ' + str(v.block_timestamp)) if v.block_timestamp is not None else 'none'}, "
            + f"expectedPrevHashHex := {_lean_opt_hex_str(v.expected_prev_hash)}, "
            + f"expectedTargetHex := {_lean_opt_hex_str(v.expected_target)}, "
            + f"prevTimestamps := [{prev_ts}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxidHex := {_lean_opt_hex_str(v.expect_txid)}, "
            + f"expectWtxidHex := {_lean_opt_hex_str(v.expect_wtxid)}, "
            + f"expectConsumed := {('some ' + str(v.expect_consumed)) if v.expect_consumed is not None else 'none'}"
            + " }"
        )
    body = ",\n".join(rows)
    return (
        "-- AUTOGENERATED: do not edit by hand.\n"
        "-- Generated from conformance/fixtures/CV-SIG.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVSigUtxoEntry where\n"
        "  txidHex : String\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantDataHex : String\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        "\n"
        "structure CVSigVector where\n"
        "  id : String\n"
        "  op : String\n"
        "  txHex : Option String\n"
        "  blockHex : Option String\n"
        "  utxos : List CVSigUtxoEntry\n"
        "  height : Option Nat\n"
        "  blockTimestamp : Option Nat\n"
        "  expectedPrevHashHex : Option String\n"
        "  expectedTargetHex : Option String\n"
        "  prevTimestamps : List Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxidHex : Option String\n"
        "  expectWtxidHex : Option String\n"
        "  expectConsumed : Option Nat\n"
        "\n"
        "def cvSigVectors : List CVSigVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Lean vector modules from conformance fixtures")
    parser.add_argument(
        "--repo-root",
        default=None,
        help="Repository root (defaults to auto-detect from this script location).",
    )
    args = parser.parse_args()

    repo_root = Path(args.repo_root).resolve() if args.repo_root else Path(__file__).resolve().parents[2]
    in_path = repo_root / "conformance" / "fixtures" / "CV-PARSE.json"
    out_path = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVParseVectors.lean"

    vectors = load_cv_parse(in_path)
    out_path.write_text(_inject_perf_options(render_cv_parse_lean(vectors)), encoding="utf-8")
    print(f"WROTE: {out_path}")

    in_merkle = repo_root / "conformance" / "fixtures" / "CV-MERKLE.json"
    out_merkle = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVMerkleVectors.lean"
    mv = load_cv_merkle(in_merkle)
    out_merkle.write_text(_inject_perf_options(render_cv_merkle_lean(mv)), encoding="utf-8")
    print(f"WROTE: {out_merkle}")

    in_od = repo_root / "conformance" / "fixtures" / "CV-OUTPUT-DESCRIPTOR.json"
    out_od = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVOutputDescriptorVectors.lean"
    odv = load_cv_output_descriptor(in_od)
    out_od.write_text(_inject_perf_options(render_cv_output_descriptor_lean(odv)), encoding="utf-8")
    print(f"WROTE: {out_od}")

    in_sighash = repo_root / "conformance" / "fixtures" / "CV-SIGHASH.json"
    out_sighash = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSighashVectors.lean"
    sv = load_cv_sighash(in_sighash)
    out_sighash.write_text(_inject_perf_options(render_cv_sighash_lean(sv)), encoding="utf-8")
    print(f"WROTE: {out_sighash}")

    in_pow = repo_root / "conformance" / "fixtures" / "CV-POW.json"
    out_pow = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVPowVectors.lean"
    pv = load_cv_pow(in_pow)
    out_pow.write_text(_inject_perf_options(render_cv_pow_lean(pv)), encoding="utf-8")
    print(f"WROTE: {out_pow}")

    in_weight = repo_root / "conformance" / "fixtures" / "CV-WEIGHT.json"
    out_weight = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVWeightVectors.lean"
    wv = load_cv_weight(in_weight)
    out_weight.write_text(_inject_perf_options(render_cv_weight_lean(wv)), encoding="utf-8")
    print(f"WROTE: {out_weight}")

    in_utxo_basic = repo_root / "conformance" / "fixtures" / "CV-UTXO-BASIC.json"
    out_utxo_basic = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVUtxoBasicVectors.lean"
    uv = load_cv_utxo_basic(in_utxo_basic)
    out_utxo_basic.write_text(_inject_perf_options(render_cv_utxo_basic_lean(uv)), encoding="utf-8")
    print(f"WROTE: {out_utxo_basic}")

    in_block_basic = repo_root / "conformance" / "fixtures" / "CV-BLOCK-BASIC.json"
    out_block_basic = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVBlockBasicVectors.lean"
    bbv = load_cv_block_basic(in_block_basic)
    out_block_basic.write_text(_inject_perf_options(render_cv_block_basic_lean(bbv)), encoding="utf-8")
    print(f"WROTE: {out_block_basic}")

    in_subsidy = repo_root / "conformance" / "fixtures" / "CV-SUBSIDY.json"
    out_subsidy = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSubsidyVectors.lean"
    subv = load_cv_subsidy(in_subsidy)
    out_subsidy.write_text(_inject_perf_options(render_cv_subsidy_lean(subv)), encoding="utf-8")
    print(f"WROTE: {out_subsidy}")

    in_da_integrity = repo_root / "conformance" / "fixtures" / "CV-DA-INTEGRITY.json"
    out_da_integrity = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVDaIntegrityVectors.lean"
    div = load_cv_da_integrity(in_da_integrity)
    out_da_integrity.write_text(_inject_perf_options(render_cv_da_integrity_lean(div)), encoding="utf-8")
    print(f"WROTE: {out_da_integrity}")

    in_cov_gen = repo_root / "conformance" / "fixtures" / "CV-COVENANT-GENESIS.json"
    out_cov_gen = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVCovenantGenesisVectors.lean"
    cgv = load_cv_covenant_genesis(in_cov_gen)
    out_cov_gen.write_text(_inject_perf_options(render_cv_covenant_genesis_lean(cgv)), encoding="utf-8")
    print(f"WROTE: {out_cov_gen}")

    in_vault = repo_root / "conformance" / "fixtures" / "CV-VAULT.json"
    out_vault = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVVaultVectors.lean"
    vv = _load_utxo_apply_vectors(json.loads(in_vault.read_text(encoding="utf-8")), "CV-VAULT")
    out_vault.write_text(_inject_perf_options(render_utxo_apply_vectors_lean(vv, "CV-VAULT")), encoding="utf-8")
    print(f"WROTE: {out_vault}")

    in_htlc = repo_root / "conformance" / "fixtures" / "CV-HTLC.json"
    out_htlc = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVHtlcVectors.lean"
    hv = _load_utxo_apply_vectors(json.loads(in_htlc.read_text(encoding="utf-8")), "CV-HTLC")
    out_htlc.write_text(_inject_perf_options(render_utxo_apply_vectors_lean(hv, "CV-HTLC")), encoding="utf-8")
    print(f"WROTE: {out_htlc}")

    in_vault_pol = repo_root / "conformance" / "fixtures" / "CV-VAULT-POLICY.json"
    out_vault_pol = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVVaultPolicyVectors.lean"
    vpv = load_cv_vault_policy(in_vault_pol)
    out_vault_pol.write_text(_inject_perf_options(render_cv_vault_policy_lean(vpv)), encoding="utf-8")
    print(f"WROTE: {out_vault_pol}")

    in_htlc_ord = repo_root / "conformance" / "fixtures" / "CV-HTLC-ORDERING.json"
    out_htlc_ord = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVHtlcOrderingVectors.lean"
    hov = load_cv_htlc_ordering(in_htlc_ord)
    out_htlc_ord.write_text(_inject_perf_options(render_cv_htlc_ordering_lean(hov)), encoding="utf-8")
    print(f"WROTE: {out_htlc_ord}")

    in_det = repo_root / "conformance" / "fixtures" / "CV-DETERMINISM.json"
    out_det = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVDeterminismVectors.lean"
    dv = load_cv_determinism(in_det)
    out_det.write_text(_inject_perf_options(render_cv_determinism_lean(dv)), encoding="utf-8")
    print(f"WROTE: {out_det}")

    in_fork = repo_root / "conformance" / "fixtures" / "CV-FORK-CHOICE.json"
    out_fork = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVForkChoiceVectors.lean"
    fcv = load_cv_fork_choice(in_fork)
    out_fork.write_text(_inject_perf_options(render_cv_fork_choice_lean(fcv)), encoding="utf-8")
    print(f"WROTE: {out_fork}")

    in_val_order = repo_root / "conformance" / "fixtures" / "CV-VALIDATION-ORDER.json"
    out_val_order = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVValidationOrderVectors.lean"
    vov = load_cv_validation_order(in_val_order)
    out_val_order.write_text(_inject_perf_options(render_cv_validation_order_lean(vov)), encoding="utf-8")
    print(f"WROTE: {out_val_order}")

    in_replay = repo_root / "conformance" / "fixtures" / "CV-REPLAY.json"
    out_replay = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVReplayVectors.lean"
    rpv = load_cv_replay(in_replay)
    out_replay.write_text(_inject_perf_options(render_cv_replay_lean(rpv)), encoding="utf-8")
    print(f"WROTE: {out_replay}")

    in_ts = repo_root / "conformance" / "fixtures" / "CV-TIMESTAMP.json"
    out_ts = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVTimestampVectors.lean"
    tsv = load_cv_timestamp(in_ts)
    out_ts.write_text(_inject_perf_options(render_cv_timestamp_lean(tsv)), encoding="utf-8")
    print(f"WROTE: {out_ts}")

    in_sig = repo_root / "conformance" / "fixtures" / "CV-SIG.json"
    out_sig = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSigVectors.lean"
    sigv = load_cv_sig(in_sig)
    out_sig.write_text(_inject_perf_options(render_cv_sig_lean(sigv)), encoding="utf-8")
    print(f"WROTE: {out_sig}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
