#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any


def _hex_to_bytes(hex_str: str) -> list[int]:
    s = hex_str.strip()
    if s.startswith("0x") or s.startswith("0X"):
        s = s[2:]
    if len(s) % 2 != 0:
        raise ValueError(f"hex length must be even: {len(s)}")
    out: list[int] = []
    for i in range(0, len(s), 2):
        out.append(int(s[i : i + 2], 16))
    return out


def _lean_bytearray_literal(bs: list[int]) -> str:
    if not bs:
        return "#[]"
    return "#[" + ", ".join(f"0x{b:02x}" for b in bs) + "]"


def _lean_opt_str(value: str | None) -> str:
    if value is None:
        return "none"
    v = value.replace("\\", "\\\\").replace('"', '\\"')
    return f'some "{v}"'


def _lean_opt_bytes_hex(hex_str: str | None) -> str:
    if hex_str is None:
        return "none"
    bs = _hex_to_bytes(hex_str)
    return f"some ({_lean_bytearray_literal(bs)})"

def _materialize_tx_hex(v: dict[str, Any]) -> str:
    tx_hex = v.get("tx_hex")
    if isinstance(tx_hex, str) and tx_hex.strip() != "":
        return tx_hex.strip()

    parts = v.get("tx_hex_parts")
    if not isinstance(parts, list) or len(parts) == 0:
        raise ValueError("missing tx_hex (or tx_hex_parts)")

    out: list[str] = []
    for p in parts:
        if isinstance(p, str):
            out.append(p.strip())
            continue
        if isinstance(p, dict):
            repeat_byte = p.get("repeat_byte")
            count = p.get("count")
            if not isinstance(repeat_byte, str) or not isinstance(count, int):
                raise ValueError("tx_hex_parts dict must have repeat_byte (string) and count (int)")
            b = repeat_byte.strip().lower()
            if b.startswith("0x"):
                b = b[2:]
            if len(b) != 2:
                raise ValueError("repeat_byte must be exactly 1 byte hex (2 chars)")
            int(b, 16)  # validate
            if count < 0:
                raise ValueError("repeat_byte count must be non-negative")
            out.append(b * count)
            continue
        raise ValueError("tx_hex_parts entries must be strings or dict repeat blocks")

    return "".join(out)


@dataclass(frozen=True)
class ParseVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None
    expect_txid: str | None
    expect_wtxid: str | None


def load_cv_parse(path: Path) -> list[ParseVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-PARSE":
        raise ValueError(f"expected gate=CV-PARSE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[ParseVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "parse_tx":
            continue
        tx_hex = _materialize_tx_hex(v)
        out.append(
            ParseVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                expect_ok=bool(v.get("expect_ok")),
                expect_err=(v.get("expect_err") if not v.get("expect_ok") else None),
                expect_txid=(v.get("expect_txid") if v.get("expect_ok") else None),
                expect_wtxid=(v.get("expect_wtxid") if v.get("expect_ok") else None),
            )
        )
    if not out:
        raise ValueError("no parse_tx vectors found")
    return out


def render_cv_parse_lean(vectors: list[ParseVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectTxid := {_lean_opt_bytes_hex(v.expect_txid)}, "
            + f"expectWtxid := {_lean_opt_bytes_hex(v.expect_wtxid)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-PARSE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVParseVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectTxid : Option Bytes\n"
        "  expectWtxid : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvParseVectors : List CVParseVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class MerkleVector:
    vid: str
    txids: list[str]
    expect_ok: bool
    expect_merkle_root: str | None
    expect_not_merkle_root: str | None


def load_cv_merkle(path: Path) -> list[MerkleVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-MERKLE":
        raise ValueError(f"expected gate=CV-MERKLE, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[MerkleVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "merkle_root":
            continue
        out.append(
            MerkleVector(
                vid=str(v.get("id") or ""),
                txids=list(v.get("txids") or []),
                expect_ok=bool(v.get("expect_ok")),
                expect_merkle_root=(v.get("expect_merkle_root") if v.get("expect_ok") else None),
                expect_not_merkle_root=v.get("expect_not_merkle_root"),
            )
        )
    if not out:
        raise ValueError("no merkle_root vectors found")
    return out


def render_cv_merkle_lean(vectors: list[MerkleVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        txid_bytes = ", ".join(f"({_lean_bytearray_literal(_hex_to_bytes(x))})" for x in v.txids)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"txids := [{txid_bytes}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectMerkleRoot := {_lean_opt_bytes_hex(v.expect_merkle_root)}, "
            + f"expectNotMerkleRoot := {_lean_opt_bytes_hex(v.expect_not_merkle_root)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-MERKLE.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVMerkleVector where\n"
        "  id : String\n"
        "  txids : List Bytes\n"
        "  expectOk : Bool\n"
        "  expectMerkleRoot : Option Bytes\n"
        "  expectNotMerkleRoot : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvMerkleVectors : List CVMerkleVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def _parse_hex_nat_u16(s: str) -> int:
    t = s.strip()
    if t.startswith("0x") or t.startswith("0X"):
        t = t[2:]
    if len(t) != 4:
        raise ValueError(f"expected u16 hex like 0x0000, got: {s!r}")
    return int(t, 16)


@dataclass(frozen=True)
class OutputDescriptorVector:
    vid: str
    op: str
    covenant_type: int
    covenant_data_hex: str
    expected_hex: str | None
    expected_hash: str | None


def load_cv_output_descriptor(path: Path) -> list[OutputDescriptorVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-OUTPUT-DESCRIPTOR":
        raise ValueError(f"expected gate=CV-OUTPUT-DESCRIPTOR, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[OutputDescriptorVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = v.get("op")
        if op not in ("output_descriptor_bytes", "output_descriptor_hash"):
            continue
        inp = v.get("input") or {}
        out.append(
            OutputDescriptorVector(
                vid=str(v.get("id") or ""),
                op=str(op),
                covenant_type=_parse_hex_nat_u16(str(inp.get("covenant_type") or "")),
                covenant_data_hex=str(inp.get("covenant_data_hex") or ""),
                expected_hex=(v.get("expected_hex") if op == "output_descriptor_bytes" else None),
                expected_hash=(v.get("expected_hash") if op == "output_descriptor_hash" else None),
            )
        )
    if not out:
        raise ValueError("no output_descriptor vectors found")
    return out


def render_cv_output_descriptor_lean(vectors: list[OutputDescriptorVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        covenant_data = _lean_bytearray_literal(_hex_to_bytes(v.covenant_data_hex))
        if v.op == "output_descriptor_bytes":
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hex or ""))
            op = ".bytes"
        else:
            expected = _lean_bytearray_literal(_hex_to_bytes(v.expected_hash or ""))
            op = ".hash"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"covenantType := {v.covenant_type}, "
            + f"covenantData := {covenant_data}, "
            + f"expected := {expected}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-OUTPUT-DESCRIPTOR.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "inductive ODOp where\n"
        "  | bytes\n"
        "  | hash\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVOutputDescriptorVector where\n"
        "  id : String\n"
        "  op : ODOp\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  expected : Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvOutputDescriptorVectors : List CVOutputDescriptorVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class SighashVector:
    vid: str
    tx_hex: str
    chain_id: str
    input_index: int
    input_value: int
    expect_digest: str


def load_cv_sighash(path: Path) -> list[SighashVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SIGHASH":
        raise ValueError(f"expected gate=CV-SIGHASH, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SighashVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "sighash_v1":
            continue
        if not v.get("expect_ok"):
            raise ValueError(f"unexpected expect_ok=false in CV-SIGHASH: {v.get('id')}")
        tx_hex = _materialize_tx_hex(v)
        out.append(
            SighashVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                chain_id=str(v.get("chain_id") or ""),
                input_index=int(v.get("input_index", 0)),
                input_value=int(v.get("input_value", 0)),
                expect_digest=str(v.get("expect_digest") or ""),
            )
        )
    if not out:
        raise ValueError("no sighash_v1 vectors found")
    return out


def render_cv_sighash_lean(vectors: list[SighashVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        chain_id = _lean_bytearray_literal(_hex_to_bytes(v.chain_id))
        digest = _lean_bytearray_literal(_hex_to_bytes(v.expect_digest))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"chainId := {chain_id}, "
            + f"inputIndex := {v.input_index}, "
            + f"inputValue := {v.input_value}, "
            + f"expectDigest := {digest}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-SIGHASH.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVSighashVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  chainId : Bytes\n"
        "  inputIndex : Nat\n"
        "  inputValue : Nat\n"
        "  expectDigest : Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvSighashVectors : List CVSighashVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class WeightVector:
    vid: str
    tx_hex: str
    expect_weight: int
    expect_da_bytes: int
    expect_anchor_bytes: int


def load_cv_weight(path: Path) -> list[WeightVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-WEIGHT":
        raise ValueError(f"expected gate=CV-WEIGHT, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[WeightVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "tx_weight_and_stats":
            continue
        if not v.get("expect_ok"):
            raise ValueError(f"unexpected expect_ok=false in CV-WEIGHT: {v.get('id')}")
        out.append(
            WeightVector(
                vid=str(v.get("id") or ""),
                tx_hex=str(v.get("tx_hex") or ""),
                expect_weight=int(v.get("expect_weight", 0)),
                expect_da_bytes=int(v.get("expect_da_bytes", 0)),
                expect_anchor_bytes=int(v.get("expect_anchor_bytes", 0)),
            )
        )
    if not out:
        raise ValueError("no tx_weight_and_stats vectors found")
    return out


def render_cv_weight_lean(vectors: list[WeightVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectWeight := {v.expect_weight}, "
            + f"expectDaBytes := {v.expect_da_bytes}, "
            + f"expectAnchorBytes := {v.expect_anchor_bytes}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-WEIGHT.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVWeightVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectWeight : Nat\n"
        "  expectDaBytes : Nat\n"
        "  expectAnchorBytes : Nat\n"
        "deriving Repr\n"
        "\n"
        "def cvWeightVectors : List CVWeightVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class PowWindowPattern:
    window_size: int
    start: int
    step: int
    last_jump: int


@dataclass(frozen=True)
class PowVector:
    vid: str
    op: str
    expect_ok: bool
    expect_err: str | None
    target_old: str | None
    timestamp_first: int | None
    timestamp_last: int | None
    window_pattern: PowWindowPattern | None
    header_hex: str | None
    target_hex: str | None
    expected_bytes_hex: str | None


def load_cv_pow(path: Path) -> list[PowVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-POW":
        raise ValueError(f"expected gate=CV-POW, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[PowVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        expect_ok = bool(v.get("expect_ok"))
        expect_err = v.get("expect_err") if not expect_ok else None

        wp: PowWindowPattern | None = None
        if isinstance(v.get("window_pattern"), dict):
            p = v["window_pattern"]
            mode = str(p.get("mode") or "")
            if mode != "step_with_last_jump":
                raise ValueError(f"unknown window_pattern.mode={mode!r} in {v.get('id')!r}")
            wp = PowWindowPattern(
                window_size=int(p.get("window_size", 10_080)),
                start=int(p.get("start", 0)),
                step=int(p.get("step", 120)),
                last_jump=int(p.get("last_jump", 0)),
            )

        expected_bytes_hex: str | None = None
        if op == "retarget_v1" and expect_ok:
            expected_bytes_hex = str(v.get("expect_target_new") or "")
        if op == "block_hash" and expect_ok:
            expected_bytes_hex = str(v.get("expect_block_hash") or "")

        out.append(
            PowVector(
                vid=str(v.get("id") or ""),
                op=op,
                expect_ok=expect_ok,
                expect_err=expect_err,
                target_old=(str(v.get("target_old")) if v.get("target_old") is not None else None),
                timestamp_first=(int(v["timestamp_first"]) if "timestamp_first" in v else None),
                timestamp_last=(int(v["timestamp_last"]) if "timestamp_last" in v else None),
                window_pattern=wp,
                header_hex=(str(v.get("header_hex")) if v.get("header_hex") is not None else None),
                target_hex=(str(v.get("target_hex")) if v.get("target_hex") is not None else None),
                expected_bytes_hex=expected_bytes_hex,
            )
        )
    if not out:
        raise ValueError("no pow vectors found")
    return out


def _lean_opt_window_pattern(p: PowWindowPattern | None) -> str:
    if p is None:
        return "none"
    return (
        "some { "
        + f"windowSize := {p.window_size}, "
        + f"start := {p.start}, "
        + f"step := {p.step}, "
        + f"lastJump := {p.last_jump}"
        + " }"
    )


def render_cv_pow_lean(vectors: list[PowVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        if v.op == "retarget_v1":
            op = ".retarget_v1"
        elif v.op == "block_hash":
            op = ".block_hash"
        elif v.op == "pow_check":
            op = ".pow_check"
        else:
            raise ValueError(f"unknown op: {v.op!r}")

        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := {op}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"targetOld := {_lean_opt_bytes_hex(v.target_old)}, "
            + f"timestampFirst := {('some ' + str(v.timestamp_first)) if v.timestamp_first is not None else 'none'}, "
            + f"timestampLast := {('some ' + str(v.timestamp_last)) if v.timestamp_last is not None else 'none'}, "
            + f"windowPattern := {_lean_opt_window_pattern(v.window_pattern)}, "
            + f"header := {_lean_opt_bytes_hex(v.header_hex)}, "
            + f"target := {_lean_opt_bytes_hex(v.target_hex)}, "
            + f"expectedBytes := {_lean_opt_bytes_hex(v.expected_bytes_hex)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-POW.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure WindowPattern where\n"
        "  windowSize : Nat\n"
        "  start : Nat\n"
        "  step : Nat\n"
        "  lastJump : Nat\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "inductive CVPowOp where\n"
        "  | retarget_v1\n"
        "  | block_hash\n"
        "  | pow_check\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVPowVector where\n"
        "  id : String\n"
        "  op : CVPowOp\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  targetOld : Option Bytes\n"
        "  timestampFirst : Option Nat\n"
        "  timestampLast : Option Nat\n"
        "  windowPattern : Option WindowPattern\n"
        "  header : Option Bytes\n"
        "  target : Option Bytes\n"
        "  expectedBytes : Option Bytes\n"
        "deriving Repr\n"
        "\n"
        "def cvPowVectors : List CVPowVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class UtxoBasicUtxo:
    txid: str
    vout: int
    value: int
    covenant_type: int
    covenant_data_hex: str
    creation_height: int
    created_by_coinbase: bool


@dataclass(frozen=True)
class UtxoBasicVector:
    vid: str
    tx_hex: str
    utxos: list[UtxoBasicUtxo]
    height: int
    block_timestamp: int
    expect_ok: bool
    expect_err: str | None
    expect_fee: int | None
    expect_utxo_count: int | None


def load_cv_utxo_basic(path: Path) -> list[UtxoBasicVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-UTXO-BASIC":
        raise ValueError(f"expected gate=CV-UTXO-BASIC, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[UtxoBasicVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "utxo_apply_basic":
            continue
        tx_hex = _materialize_tx_hex(v)
        utxos: list[UtxoBasicUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                UtxoBasicUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            UtxoBasicVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                utxos=utxos,
                height=int(v.get("height", 0)),
                block_timestamp=int(v.get("block_timestamp", 0)),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_fee=(int(v.get("expect_fee")) if expect_ok and "expect_fee" in v else None),
                expect_utxo_count=(
                    int(v.get("expect_utxo_count")) if expect_ok and "expect_utxo_count" in v else None
                ),
            )
        )
    if not out:
        raise ValueError("no utxo_apply_basic vectors found")
    return out


def render_cv_utxo_basic_lean(vectors: list[UtxoBasicVector]) -> str:
    def render_utxo(u: UtxoBasicUtxo) -> str:
        txid = _lean_bytearray_literal(_hex_to_bytes(u.txid))
        cd = _lean_bytearray_literal(_hex_to_bytes(u.covenant_data_hex))
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txid := {txid}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantData := {cd}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"utxos := [{utxo_rows}], "
            + f"height := {v.height}, "
            + f"blockTimestamp := {v.block_timestamp}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectFee := {('some ' + str(v.expect_fee)) if v.expect_fee is not None else 'none'}, "
            + f"expectUtxoCount := {('some ' + str(v.expect_utxo_count)) if v.expect_utxo_count is not None else 'none'}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-UTXO-BASIC.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVUtxoEntry where\n"
        "  txid : Bytes\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        "deriving Repr\n"
        "\n"
        "structure CVUtxoBasicVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  utxos : List CVUtxoEntry\n"
        "  height : Nat\n"
        "  blockTimestamp : Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectFee : Option Nat\n"
        "  expectUtxoCount : Option Nat\n"
        "deriving Repr\n"
        "\n"
        "def cvUtxoBasicVectors : List CVUtxoBasicVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class BlockBasicVector:
    vid: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    expect_ok: bool
    expect_err: str | None


def load_cv_block_basic(path: Path) -> list[BlockBasicVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-BLOCK-BASIC":
        raise ValueError(f"expected gate=CV-BLOCK-BASIC, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[BlockBasicVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "block_basic_check":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            BlockBasicVector(
                vid=str(v.get("id") or ""),
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no block_basic_check vectors found")
    return out


def render_cv_block_basic_lean(vectors: list[BlockBasicVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        block_bytes = _lean_bytearray_literal(_hex_to_bytes(v.block_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"block := {block_bytes}, "
            + f"expectedPrevHash := {_lean_opt_bytes_hex(v.expected_prev_hash)}, "
            + f"expectedTarget := {_lean_opt_bytes_hex(v.expected_target)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-BLOCK-BASIC.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVBlockBasicVector where\n"
        "  id : String\n"
        "  block : Bytes\n"
        "  expectedPrevHash : Option Bytes\n"
        "  expectedTarget : Option Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "deriving Repr\n"
        "\n"
        "def cvBlockBasicVectors : List CVBlockBasicVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class SubsidyUtxo:
    txid: str
    vout: int
    value: int
    covenant_type: int
    covenant_data_hex: str
    creation_height: int
    created_by_coinbase: bool


@dataclass(frozen=True)
class SubsidyVector:
    vid: str
    op: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    height: int
    already_generated: int
    sum_fees: int | None
    utxos: list[SubsidyUtxo]
    expect_ok: bool
    expect_err: str | None


def load_cv_subsidy(path: Path) -> list[SubsidyVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-SUBSIDY":
        raise ValueError(f"expected gate=CV-SUBSIDY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[SubsidyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        op = str(v.get("op") or "")
        if op not in ("connect_block_basic", "block_basic_check_with_fees"):
            continue
        utxos: list[SubsidyUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                SubsidyUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            SubsidyVector(
                vid=str(v.get("id") or ""),
                op=op,
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                height=int(v.get("height", 0)),
                already_generated=int(v.get("already_generated", 0)),
                sum_fees=(int(v.get("sum_fees")) if "sum_fees" in v else None),
                utxos=utxos,
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no subsidy vectors found")
    return out


def render_cv_subsidy_lean(vectors: list[SubsidyVector]) -> str:
    def render_utxo(u: SubsidyUtxo) -> str:
        txid = _lean_bytearray_literal(_hex_to_bytes(u.txid))
        cd = _lean_bytearray_literal(_hex_to_bytes(u.covenant_data_hex))
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txid := {txid}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantData := {cd}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        block_bytes = _lean_bytearray_literal(_hex_to_bytes(v.block_hex))
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        sum_fees = f"some {v.sum_fees}" if v.sum_fees is not None else "none"
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"op := .{v.op}, "
            + f"block := {block_bytes}, "
            + f"expectedPrevHash := {_lean_opt_bytes_hex(v.expected_prev_hash)}, "
            + f"expectedTarget := {_lean_opt_bytes_hex(v.expected_target)}, "
            + f"height := {v.height}, "
            + f"alreadyGenerated := {v.already_generated}, "
            + f"sumFees := {sum_fees}, "
            + f"utxos := [{utxo_rows}], "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-SUBSIDY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVSubsidyUtxo where\n"
        "  txid : Bytes\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        "deriving Repr\n"
        "\n"
        "inductive CVSubsidyOp where\n"
        "  | connect_block_basic\n"
        "  | block_basic_check_with_fees\n"
        "deriving Repr, DecidableEq\n"
        "\n"
        "structure CVSubsidyVector where\n"
        "  id : String\n"
        "  op : CVSubsidyOp\n"
        "  block : Bytes\n"
        "  expectedPrevHash : Option Bytes\n"
        "  expectedTarget : Option Bytes\n"
        "  height : Nat\n"
        "  alreadyGenerated : Nat\n"
        "  sumFees : Option Nat\n"
        "  utxos : List CVSubsidyUtxo\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "deriving Repr\n"
        "\n"
        "def cvSubsidyVectors : List CVSubsidyVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )

@dataclass(frozen=True)
class DaIntegrityVector:
    vid: str
    block_hex: str
    expected_prev_hash: str | None
    expected_target: str | None
    expect_ok: bool
    expect_err: str | None


def load_cv_da_integrity(path: Path) -> list[DaIntegrityVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-DA-INTEGRITY":
        raise ValueError(f"expected gate=CV-DA-INTEGRITY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[DaIntegrityVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "block_basic_check":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            DaIntegrityVector(
                vid=str(v.get("id") or ""),
                block_hex=str(v.get("block_hex") or ""),
                expected_prev_hash=(str(v.get("expected_prev_hash")) if "expected_prev_hash" in v else None),
                expected_target=(str(v.get("expected_target")) if "expected_target" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no DA integrity vectors found")
    return out


def render_cv_da_integrity_lean(vectors: list[DaIntegrityVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        block_bytes = _lean_bytearray_literal(_hex_to_bytes(v.block_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"block := {block_bytes}, "
            + f"expectedPrevHash := {_lean_opt_bytes_hex(v.expected_prev_hash)}, "
            + f"expectedTarget := {_lean_opt_bytes_hex(v.expected_target)}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-DA-INTEGRITY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVDaIntegrityVector where\n"
        "  id : String\n"
        "  block : Bytes\n"
        "  expectedPrevHash : Option Bytes\n"
        "  expectedTarget : Option Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "deriving Repr\n"
        "\n"
        "def cvDaIntegrityVectors : List CVDaIntegrityVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class CovenantGenesisVector:
    vid: str
    tx_hex: str
    expect_ok: bool
    expect_err: str | None


def load_cv_covenant_genesis(path: Path) -> list[CovenantGenesisVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-COVENANT-GENESIS":
        raise ValueError(f"expected gate=CV-COVENANT-GENESIS, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[CovenantGenesisVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "covenant_genesis_check":
            continue
        tx_hex = _materialize_tx_hex(v)
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            CovenantGenesisVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no covenant_genesis_check vectors found")
    return out


def render_cv_covenant_genesis_lean(vectors: list[CovenantGenesisVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )

    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-COVENANT-GENESIS.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        "structure CVCovenantGenesisVector where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "deriving Repr\n"
        "\n"
        "def cvCovenantGenesisVectors : List CVCovenantGenesisVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class UtxoApplyVector:
    vid: str
    tx_hex: str
    utxos: list[UtxoBasicUtxo]
    height: int
    block_timestamp: int
    block_mtp: int | None
    expect_ok: bool
    expect_err: str | None
    expect_fee: int | None
    expect_utxo_count: int | None


def _load_utxo_apply_vectors(doc: dict[str, Any], gate: str) -> list[UtxoApplyVector]:
    if doc.get("gate") != gate:
        raise ValueError(f"expected gate={gate}, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[UtxoApplyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "utxo_apply_basic":
            continue
        tx_hex = _materialize_tx_hex(v)
        utxos: list[UtxoBasicUtxo] = []
        for u in v.get("utxos") or []:
            utxos.append(
                UtxoBasicUtxo(
                    txid=str(u.get("txid") or ""),
                    vout=int(u.get("vout", 0)),
                    value=int(u.get("value", 0)),
                    covenant_type=int(u.get("covenant_type", 0)),
                    covenant_data_hex=str(u.get("covenant_data") or ""),
                    creation_height=int(u.get("creation_height", 0)),
                    created_by_coinbase=bool(u.get("created_by_coinbase", False)),
                )
            )
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            UtxoApplyVector(
                vid=str(v.get("id") or ""),
                tx_hex=tx_hex,
                utxos=utxos,
                height=int(v.get("height", 0)),
                block_timestamp=int(v.get("block_timestamp", 0)),
                block_mtp=(int(v.get("block_mtp")) if "block_mtp" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_fee=(int(v.get("expect_fee")) if expect_ok and "expect_fee" in v else None),
                expect_utxo_count=(
                    int(v.get("expect_utxo_count")) if expect_ok and "expect_utxo_count" in v else None
                ),
            )
        )
    if not out:
        raise ValueError("no utxo_apply_basic vectors found")
    return out


def render_utxo_apply_vectors_lean(vectors: list[UtxoApplyVector], gate: str) -> str:
    def render_utxo(u: UtxoBasicUtxo) -> str:
        txid = _lean_bytearray_literal(_hex_to_bytes(u.txid))
        cd = _lean_bytearray_literal(_hex_to_bytes(u.covenant_data_hex))
        created = "true" if u.created_by_coinbase else "false"
        return (
            "{ "
            + f"txid := {txid}, "
            + f"vout := {u.vout}, "
            + f"value := {u.value}, "
            + f"covenantType := {u.covenant_type}, "
            + f"covenantData := {cd}, "
            + f"creationHeight := {u.creation_height}, "
            + f"createdByCoinbase := {created}"
            + " }"
        )

    rows: list[str] = []
    for v in vectors:
        tx_bytes = _lean_bytearray_literal(_hex_to_bytes(v.tx_hex))
        utxo_rows = ", ".join(render_utxo(u) for u in v.utxos)
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"tx := {tx_bytes}, "
            + f"utxos := [{utxo_rows}], "
            + f"height := {v.height}, "
            + f"blockTimestamp := {v.block_timestamp}, "
            + f"blockMtp := {('some ' + str(v.block_mtp)) if v.block_mtp is not None else 'none'}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectFee := {('some ' + str(v.expect_fee)) if v.expect_fee is not None else 'none'}, "
            + f"expectUtxoCount := {('some ' + str(v.expect_utxo_count)) if v.expect_utxo_count is not None else 'none'}"
            + " }"
        )
    body = "\n".join(rows)
    tag = gate.replace("-", "_")
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        f"// Generated from conformance/fixtures/{gate}.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "abbrev Bytes := ByteArray\n"
        "\n"
        f"structure CVUtxoEntry_{tag} where\n"
        "  txid : Bytes\n"
        "  vout : Nat\n"
        "  value : Nat\n"
        "  covenantType : Nat\n"
        "  covenantData : Bytes\n"
        "  creationHeight : Nat\n"
        "  createdByCoinbase : Bool\n"
        "deriving Repr\n"
        "\n"
        f"structure CVUtxoApplyVector_{tag} where\n"
        "  id : String\n"
        "  tx : Bytes\n"
        f"  utxos : List CVUtxoEntry_{tag}\n"
        "  height : Nat\n"
        "  blockTimestamp : Nat\n"
        "  blockMtp : Option Nat\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectFee : Option Nat\n"
        "  expectUtxoCount : Option Nat\n"
        "deriving Repr\n"
        "\n"
        f"def cvUtxoApplyVectors_{tag} : List CVUtxoApplyVector_{tag} := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class VaultPolicyVector:
    vid: str
    vault_input_count: int
    owner_lock_id: str
    non_vault_lock_ids: list[str]
    has_owner_auth: bool
    sum_in_vault: int
    sum_out: int
    slots: int
    key_count: int
    sig_threshold_ok: bool
    sentinel_suite_id: int
    sentinel_pubkey_len: int
    sentinel_sig_len: int
    sentinel_verify_called: bool
    whitelist: list[str]
    validation_order: list[str] | None
    expect_ok: bool
    expect_err: str | None


def load_cv_vault_policy(path: Path) -> list[VaultPolicyVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-VAULT-POLICY":
        raise ValueError(f"expected gate=CV-VAULT-POLICY, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[VaultPolicyVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "vault_policy_rules":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            VaultPolicyVector(
                vid=str(v.get("id") or ""),
                vault_input_count=int(v.get("vault_input_count", 0)),
                owner_lock_id=str(v.get("owner_lock_id", "")),
                non_vault_lock_ids=[str(x) for x in v.get("non_vault_lock_ids", [])],
                has_owner_auth=bool(v.get("has_owner_auth", False)),
                sum_in_vault=int(v.get("sum_in_vault", 0)),
                sum_out=int(v.get("sum_out", 0)),
                slots=int(v.get("slots", 0)),
                key_count=int(v.get("key_count", 0)),
                sig_threshold_ok=bool(v.get("sig_threshold_ok", True)),
                sentinel_suite_id=int(v.get("sentinel_suite_id", 0)),
                sentinel_pubkey_len=int(v.get("sentinel_pubkey_len", 0)),
                sentinel_sig_len=int(v.get("sentinel_sig_len", 0)),
                sentinel_verify_called=bool(v.get("sentinel_verify_called", False)),
                whitelist=[str(x) for x in v.get("whitelist", [])],
                validation_order=([str(x) for x in v["validation_order"]] if "validation_order" in v else None),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
            )
        )
    if not out:
        raise ValueError("no vault_policy_rules vectors found")
    return out


def render_cv_vault_policy_lean(vectors: list[VaultPolicyVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        non_vault = ", ".join(f"\"{x}\"" for x in v.non_vault_lock_ids)
        wl = ", ".join(f"\"{x}\"" for x in v.whitelist)
        order = (
            "none"
            if v.validation_order is None
            else "some [" + ", ".join(f"\"{x}\"" for x in v.validation_order) + "]"
        )
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f"vaultInputCount := {v.vault_input_count}, "
            + f'ownerLockId := "{v.owner_lock_id}", '
            + f"nonVaultLockIds := [{non_vault}], "
            + f"hasOwnerAuth := {'true' if v.has_owner_auth else 'false'}, "
            + f"sumInVault := {v.sum_in_vault}, "
            + f"sumOut := {v.sum_out}, "
            + f"slots := {v.slots}, "
            + f"keyCount := {v.key_count}, "
            + f"sigThresholdOk := {'true' if v.sig_threshold_ok else 'false'}, "
            + f"sentinelSuiteId := {v.sentinel_suite_id}, "
            + f"sentinelPubkeyLen := {v.sentinel_pubkey_len}, "
            + f"sentinelSigLen := {v.sentinel_sig_len}, "
            + f"sentinelVerifyCalled := {'true' if v.sentinel_verify_called else 'false'}, "
            + f"whitelist := [{wl}], "
            + f"validationOrder := {order}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}"
            + " }"
        )
    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-VAULT-POLICY.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVVaultPolicyVector where\n"
        "  id : String\n"
        "  vaultInputCount : Nat\n"
        "  ownerLockId : String\n"
        "  nonVaultLockIds : List String\n"
        "  hasOwnerAuth : Bool\n"
        "  sumInVault : Nat\n"
        "  sumOut : Nat\n"
        "  slots : Nat\n"
        "  keyCount : Nat\n"
        "  sigThresholdOk : Bool\n"
        "  sentinelSuiteId : Nat\n"
        "  sentinelPubkeyLen : Nat\n"
        "  sentinelSigLen : Nat\n"
        "  sentinelVerifyCalled : Bool\n"
        "  whitelist : List String\n"
        "  validationOrder : Option (List String)\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "deriving Repr\n"
        "\n"
        "def cvVaultPolicyVectors : List CVVaultPolicyVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


@dataclass(frozen=True)
class HtlcOrderingVector:
    vid: str
    path: str
    structural_ok: bool
    locktime_ok: bool
    suite_id: int
    block_height: int
    activation_height: int
    key_binding_ok: bool
    preimage_ok: bool
    verify_ok: bool
    expect_ok: bool
    expect_err: str | None
    expect_verify_called: bool


def load_cv_htlc_ordering(path: Path) -> list[HtlcOrderingVector]:
    doc = json.loads(path.read_text(encoding="utf-8"))
    if doc.get("gate") != "CV-HTLC-ORDERING":
        raise ValueError(f"expected gate=CV-HTLC-ORDERING, got {doc.get('gate')!r}")
    vectors = doc.get("vectors")
    if not isinstance(vectors, list):
        raise ValueError("vectors must be a list")
    out: list[HtlcOrderingVector] = []
    for v in vectors:
        if not isinstance(v, dict):
            continue
        if v.get("op") != "htlc_ordering_policy":
            continue
        expect_ok = bool(v.get("expect_ok"))
        out.append(
            HtlcOrderingVector(
                vid=str(v.get("id") or ""),
                path=str(v.get("path", "claim")),
                structural_ok=bool(v.get("structural_ok", True)),
                locktime_ok=bool(v.get("locktime_ok", True)),
                suite_id=int(v.get("suite_id", 1)),
                block_height=int(v.get("block_height", 0)),
                activation_height=int(v.get("slh_activation_height", 1_000_000)),
                key_binding_ok=bool(v.get("key_binding_ok", True)),
                preimage_ok=bool(v.get("preimage_ok", True)),
                verify_ok=bool(v.get("verify_ok", True)),
                expect_ok=expect_ok,
                expect_err=(str(v.get("expect_err")) if not expect_ok else None),
                expect_verify_called=bool(v.get("expect_verify_called", False)),
            )
        )
    if not out:
        raise ValueError("no htlc_ordering_policy vectors found")
    return out


def render_cv_htlc_ordering_lean(vectors: list[HtlcOrderingVector]) -> str:
    rows: list[str] = []
    for v in vectors:
        rows.append(
            "  { "
            + f'id := "{v.vid}", '
            + f'path := "{v.path}", '
            + f"structuralOk := {'true' if v.structural_ok else 'false'}, "
            + f"locktimeOk := {'true' if v.locktime_ok else 'false'}, "
            + f"suiteId := {v.suite_id}, "
            + f"blockHeight := {v.block_height}, "
            + f"slhActivationHeight := {v.activation_height}, "
            + f"keyBindingOk := {'true' if v.key_binding_ok else 'false'}, "
            + f"preimageOk := {'true' if v.preimage_ok else 'false'}, "
            + f"verifyOk := {'true' if v.verify_ok else 'false'}, "
            + f"expectOk := {'true' if v.expect_ok else 'false'}, "
            + f"expectErr := {_lean_opt_str(v.expect_err)}, "
            + f"expectVerifyCalled := {'true' if v.expect_verify_called else 'false'}"
            + " }"
        )
    body = "\n".join(rows)
    return (
        "// AUTOGENERATED: do not edit by hand.\n"
        "// Generated from conformance/fixtures/CV-HTLC-ORDERING.json via tools/formal/gen_lean_conformance_vectors.py\n"
        "\n"
        "namespace RubinFormal.Conformance\n"
        "\n"
        "structure CVHtlcOrderingVector where\n"
        "  id : String\n"
        "  path : String\n"
        "  structuralOk : Bool\n"
        "  locktimeOk : Bool\n"
        "  suiteId : Nat\n"
        "  blockHeight : Nat\n"
        "  slhActivationHeight : Nat\n"
        "  keyBindingOk : Bool\n"
        "  preimageOk : Bool\n"
        "  verifyOk : Bool\n"
        "  expectOk : Bool\n"
        "  expectErr : Option String\n"
        "  expectVerifyCalled : Bool\n"
        "deriving Repr\n"
        "\n"
        "def cvHtlcOrderingVectors : List CVHtlcOrderingVector := [\n"
        + body
        + "\n]\n"
        "\n"
        "end RubinFormal.Conformance\n"
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate Lean vector modules from conformance fixtures")
    parser.add_argument(
        "--repo-root",
        default=None,
        help="Repository root (defaults to auto-detect from this script location).",
    )
    args = parser.parse_args()

    repo_root = Path(args.repo_root).resolve() if args.repo_root else Path(__file__).resolve().parents[2]
    in_path = repo_root / "conformance" / "fixtures" / "CV-PARSE.json"
    out_path = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVParseVectors.lean"

    vectors = load_cv_parse(in_path)
    out_path.write_text(render_cv_parse_lean(vectors), encoding="utf-8")
    print(f"WROTE: {out_path}")

    in_merkle = repo_root / "conformance" / "fixtures" / "CV-MERKLE.json"
    out_merkle = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVMerkleVectors.lean"
    mv = load_cv_merkle(in_merkle)
    out_merkle.write_text(render_cv_merkle_lean(mv), encoding="utf-8")
    print(f"WROTE: {out_merkle}")

    in_od = repo_root / "conformance" / "fixtures" / "CV-OUTPUT-DESCRIPTOR.json"
    out_od = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVOutputDescriptorVectors.lean"
    odv = load_cv_output_descriptor(in_od)
    out_od.write_text(render_cv_output_descriptor_lean(odv), encoding="utf-8")
    print(f"WROTE: {out_od}")

    in_sighash = repo_root / "conformance" / "fixtures" / "CV-SIGHASH.json"
    out_sighash = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSighashVectors.lean"
    sv = load_cv_sighash(in_sighash)
    out_sighash.write_text(render_cv_sighash_lean(sv), encoding="utf-8")
    print(f"WROTE: {out_sighash}")

    in_pow = repo_root / "conformance" / "fixtures" / "CV-POW.json"
    out_pow = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVPowVectors.lean"
    pv = load_cv_pow(in_pow)
    out_pow.write_text(render_cv_pow_lean(pv), encoding="utf-8")
    print(f"WROTE: {out_pow}")

    in_weight = repo_root / "conformance" / "fixtures" / "CV-WEIGHT.json"
    out_weight = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVWeightVectors.lean"
    wv = load_cv_weight(in_weight)
    out_weight.write_text(render_cv_weight_lean(wv), encoding="utf-8")
    print(f"WROTE: {out_weight}")

    in_utxo_basic = repo_root / "conformance" / "fixtures" / "CV-UTXO-BASIC.json"
    out_utxo_basic = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVUtxoBasicVectors.lean"
    uv = load_cv_utxo_basic(in_utxo_basic)
    out_utxo_basic.write_text(render_cv_utxo_basic_lean(uv), encoding="utf-8")
    print(f"WROTE: {out_utxo_basic}")

    in_block_basic = repo_root / "conformance" / "fixtures" / "CV-BLOCK-BASIC.json"
    out_block_basic = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVBlockBasicVectors.lean"
    bbv = load_cv_block_basic(in_block_basic)
    out_block_basic.write_text(render_cv_block_basic_lean(bbv), encoding="utf-8")
    print(f"WROTE: {out_block_basic}")

    in_subsidy = repo_root / "conformance" / "fixtures" / "CV-SUBSIDY.json"
    out_subsidy = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVSubsidyVectors.lean"
    subv = load_cv_subsidy(in_subsidy)
    out_subsidy.write_text(render_cv_subsidy_lean(subv), encoding="utf-8")
    print(f"WROTE: {out_subsidy}")

    in_da_integrity = repo_root / "conformance" / "fixtures" / "CV-DA-INTEGRITY.json"
    out_da_integrity = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVDaIntegrityVectors.lean"
    div = load_cv_da_integrity(in_da_integrity)
    out_da_integrity.write_text(render_cv_da_integrity_lean(div), encoding="utf-8")
    print(f"WROTE: {out_da_integrity}")

    in_cov_gen = repo_root / "conformance" / "fixtures" / "CV-COVENANT-GENESIS.json"
    out_cov_gen = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVCovenantGenesisVectors.lean"
    cgv = load_cv_covenant_genesis(in_cov_gen)
    out_cov_gen.write_text(render_cv_covenant_genesis_lean(cgv), encoding="utf-8")
    print(f"WROTE: {out_cov_gen}")

    in_vault = repo_root / "conformance" / "fixtures" / "CV-VAULT.json"
    out_vault = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVVaultVectors.lean"
    vv = _load_utxo_apply_vectors(json.loads(in_vault.read_text(encoding="utf-8")), "CV-VAULT")
    out_vault.write_text(render_utxo_apply_vectors_lean(vv, "CV-VAULT"), encoding="utf-8")
    print(f"WROTE: {out_vault}")

    in_htlc = repo_root / "conformance" / "fixtures" / "CV-HTLC.json"
    out_htlc = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVHtlcVectors.lean"
    hv = _load_utxo_apply_vectors(json.loads(in_htlc.read_text(encoding="utf-8")), "CV-HTLC")
    out_htlc.write_text(render_utxo_apply_vectors_lean(hv, "CV-HTLC"), encoding="utf-8")
    print(f"WROTE: {out_htlc}")

    in_vault_pol = repo_root / "conformance" / "fixtures" / "CV-VAULT-POLICY.json"
    out_vault_pol = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVVaultPolicyVectors.lean"
    vpv = load_cv_vault_policy(in_vault_pol)
    out_vault_pol.write_text(render_cv_vault_policy_lean(vpv), encoding="utf-8")
    print(f"WROTE: {out_vault_pol}")

    in_htlc_ord = repo_root / "conformance" / "fixtures" / "CV-HTLC-ORDERING.json"
    out_htlc_ord = repo_root / "rubin-formal" / "RubinFormal" / "Conformance" / "CVHtlcOrderingVectors.lean"
    hov = load_cv_htlc_ordering(in_htlc_ord)
    out_htlc_ord.write_text(render_cv_htlc_ordering_lean(hov), encoding="utf-8")
    print(f"WROTE: {out_htlc_ord}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
