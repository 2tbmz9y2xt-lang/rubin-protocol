# OpenSSL PQ Bundle & Benchmark

## Build local bundle (OpenSSL 3.5+)

```bash
cd <REPO_ROOT>
OPENSSL_VERSION=3.5.5 scripts/dev-env.sh -- bash scripts/crypto/openssl/build-openssl-bundle.sh
```

Default install prefix:

`$HOME/.cache/rubin-openssl/bundle-<version>`

FIPS artifacts produced by the bundle script:

- `lib/ossl-modules/fips.*` (installed by `make install_fips`)
- `ssl/fipsmodule.cnf` (generated by `openssl fipsinstall`)
- `ssl/openssl-fips.cnf` (runtime config with `default_properties = fips=yes`)

FIPS provider preflight:

```bash
RUBIN_OPENSSL_PREFIX="$HOME/.cache/rubin-openssl/bundle-<version>" \
RUBIN_OPENSSL_MODULES="$HOME/.cache/rubin-openssl/bundle-<version>/lib/ossl-modules" \
RUBIN_OPENSSL_CONF="$HOME/.cache/rubin-openssl/bundle-<version>/ssl/openssl-fips.cnf" \
RUBIN_OPENSSL_FIPS_MODE=only \
scripts/dev-env.sh -- scripts/crypto/openssl/fips-preflight.sh
```

Runtime enforcement in `RUBIN_OPENSSL_FIPS_MODE=only`:

- `scripts/dev-env.sh -- <cmd>` now runs the same preflight automatically and hard-fails when
  `provider=fips`/required PQ signatures are unavailable.
- Temporary bypass (for bootstrap/debug only): set `RUBIN_OPENSSL_SKIP_FIPS_GUARD=1`.

## Thread-safety assumptions (verify/sign paths)

OpenSSL usage in this repository relies on the following invariants:

- `ERR_*` queue is thread-local; each verify/sign call starts with `ERR_clear_error()` and reads
  errors from the current thread only.
- `EVP_MD_CTX` and `EVP_PKEY` are created/freed per call; no shared mutable crypto context is reused
  across goroutines/threads.
- Shared immutable bytes (`pubkey`, `signature`, `digest`) are safe to read in parallel.
- Do not cache or share mutable `EVP_MD_CTX`/`EVP_PKEY_CTX` instances across workers.

Operational implication:

- Parallel `verify_sig` is supported, but context lifecycle must remain strictly per-call.
- Any optimization that introduces shared mutable OpenSSL contexts is out of policy and must be rejected.

## Run PQ benchmark (OpenSSL `speed`, primary)

```bash
cd <REPO_ROOT>
scripts/dev-env.sh -- python3 scripts/crypto/openssl/bench-pq-speed.py \
  --openssl-bin "$HOME/.cache/rubin-openssl/bundle-<version>/bin/openssl" \
  --seconds 5 \
  --output-json <OUTPUT_JSON_PATH>
```

Notes:

- This benchmark uses in-process OpenSSL `speed` and gives realistic sign/verify throughput.

## Audit baseline (Apple Silicon, 16 cores)

Reference command:

```bash
scripts/dev-env.sh -- "$HOME/.cache/rubin-openssl/bundle-<version>/bin/openssl" speed \
  -elapsed -multi 16 -seconds 30 \
  -signature-algorithms ML-DSA-87 SLH-DSA-SHAKE-256f
```

Reference result (2026-02-23, local macOS host):

- `ML-DSA-87 verify/s = 102012.8`
- `SLH-DSA-SHAKE-256f verify/s = 7360.8`
- `verify latency ratio (SLH / ML-DSA) â‰ˆ 13.86x`

Interpretation:

- This is a local workstation baseline for audit comparability.
- Absolute throughput depends on host class and scheduler; use this as a fixed local reference, not a server capacity claim.

## Optional fallback benchmark (`pkeyutl` loop)

```bash
cd <REPO_ROOT>
scripts/dev-env.sh -- python3 scripts/crypto/openssl/bench-pq-pkeyutl.py \
  --openssl-bin "$HOME/.cache/rubin-openssl/bundle-<version>/bin/openssl" \
  --output-json <OUTPUT_JSON_PATH>
```
