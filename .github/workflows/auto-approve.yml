name: Auto-approve PR

on:
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]
  status:
  workflow_run:
    workflows: [ci]
    types: [completed]

permissions:
  pull-requests: write
  contents: write

jobs:
  auto-approve:
    runs-on: ubuntu-latest
    if: github.event.pull_request || github.event.check_suite || github.event.sha || github.event.workflow_run
    steps:
      - name: Wait for all checks, approve and merge
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const MAX_ATTEMPTS = 30;
            const POLL_INTERVAL = 30000; // 30 seconds

            // --- Find PR number ---
            let prNumber;

            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.workflow_run) {
              const branch = context.payload.workflow_run.head_branch;
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${branch}`
              });
              if (prs.data.length > 0) prNumber = prs.data[0].number;
            }

            if (!prNumber) {
              const sha = context.payload.check_suite?.head_sha || context.payload.sha;
              if (!sha) {
                console.log('No SHA found, skipping');
                return;
              }
              const pulls = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: sha
              });
              const open = pulls.data.filter(p => p.state === 'open');
              if (open.length > 0) {
                prNumber = open[0].number;
              } else {
                const allPrs = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  per_page: 10
                });
                for (const pr of allPrs.data) {
                  if (pr.head.sha === sha) {
                    prNumber = pr.number;
                    break;
                  }
                }
              }
            }

            if (!prNumber) {
              console.log('No open PR found, skipping');
              return;
            }

            console.log(`Found PR #${prNumber}`);

            // --- Poll for checks to complete ---
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const ref = pr.data.head.sha;

            for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: ref,
                per_page: 100
              });

              const pending = checks.data.check_runs.filter(
                c => c.name !== 'auto-approve' && c.status !== 'completed'
              );
              const failed = checks.data.check_runs.filter(
                c => c.name !== 'auto-approve' && c.status === 'completed'
                  && c.conclusion !== 'success' && c.conclusion !== 'skipped'
                  && c.conclusion !== 'neutral'
              );

              if (failed.length > 0) {
                console.log(`${failed.length} checks failed, not approving:`);
                for (const f of failed) {
                  console.log(`  FAILED: ${f.name} - ${f.conclusion}`);
                }
                return;
              }

              if (pending.length === 0) {
                console.log(`All checks passed (attempt ${attempt})`);
                break;
              }

              if (attempt === MAX_ATTEMPTS) {
                console.log(`Timeout: still ${pending.length} checks pending after ${MAX_ATTEMPTS} attempts`);
                for (const p of pending) {
                  console.log(`  PENDING: ${p.name} - ${p.status}`);
                }
                return;
              }

              console.log(`Attempt ${attempt}: ${pending.length} checks pending, waiting ${POLL_INTERVAL/1000}s...`);
              await new Promise(r => setTimeout(r, POLL_INTERVAL));
            }

            // --- Check existing reviews ---
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const approved = reviews.data.some(
              r => r.user.login === 'github-actions[bot]' && r.state === 'APPROVED'
            );

            if (!approved) {
              console.log(`All checks passed for PR #${prNumber}, approving...`);
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                event: 'APPROVE',
                body: 'All CI checks passed. Auto-approved by workflow.'
              });
            } else {
              console.log('Already approved by github-actions[bot]');
            }

            // --- Auto-merge ---
            console.log(`Merging PR #${prNumber}...`);
            try {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash'
              });
              console.log(`PR #${prNumber} merged successfully`);
            } catch (mergeError) {
              console.log(`Merge failed: ${mergeError.message}`);
              return;
            }

            // --- Delete branch ---
            const prData = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const branchName = prData.data.head.ref;
            if (branchName !== 'main' && branchName !== 'master') {
              try {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${branchName}`
                });
                console.log(`Branch ${branchName} deleted`);
              } catch (delError) {
                console.log(`Branch deletion failed: ${delError.message}`);
              }
            }
